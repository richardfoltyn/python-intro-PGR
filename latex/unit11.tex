\documentclass{scrartcl}

	\usepackage{jupyterlatex}

    \usepackage[breakable]{tcolorbox}
    

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro

    \usepackage{iftex}
    \ifPDFTeX
        \usepackage[T1]{fontenc}
        \IfFileExists{alphabeta.sty}{
              \usepackage{alphabeta}
          }{
              \usepackage[mathletters]{ucs}
              \usepackage[utf8]{inputenc}
          }
    \else
        \usepackage{fontspec}
        \usepackage{unicode-math}
    \fi

    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage{array}     % table support for pandoc >= 2.11.3
    \usepackage{calc}      % table minipage width calculation for pandoc >= 2.11.1
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}

    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}


    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \newcommand*{\unitcounter}{11}
    \addtocounter{section}{\unitcounter}
    \addtocounter{section}{-1}
    \newcommand*{\mytitle}{Unit \unitcounter: Solving household problems in macroeconomics and finance}

	\input{overrides-post}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb.
    \makeatletter
        \newbox\Wrappedcontinuationbox
        \newbox\Wrappedvisiblespacebox
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}}
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}}
        \newcommand*\Wrappedcontinuationindent {3ex }
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox}
        % Take advantage of the already applied Pygments mark-up to insert
        % potential linebreaks for TeX processing.
        %        {, <, #, %, $, ' and ": go to next line.
        %        _, }, ^, &, >, - and ~: stay at end of broken line.
        % Use of \textquotesingle for straight quote.
        \newcommand*\Wrappedbreaksatspecials {%
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}%
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}%
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}%
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}%
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}%
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}%
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}%
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}%
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}%
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}%
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}%
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}%
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}%
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}%
        }
        % Some characters . , ; ? ! / are not pygmentized.
        % This macro makes them "active" and they will insert potential linebreaks
        \newcommand*\Wrappedbreaksatpunct {%
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}%
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}%
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}%
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}%
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}%
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}%
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}%
            \catcode`\.\active
            \catcode`\,\active
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active
            \lccode`\~`\~
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%

        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active
        \OriginalVerbatim[#1,fontsize=\small,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{FCFCFC}

    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
	\tableofcontents
    
    

    
    \hypertarget{solving-household-problems-in-macroeconomics-and-finance}{%
\section{Solving household problems in macroeconomics and
finance}\label{solving-household-problems-in-macroeconomics-and-finance}}

In this unit, we explore how to solve simple consumption-savings
problems that are common in (heterogeneous-agent) macroeconomics and
household finance.

For simplicity, we study infinite-horizon problems even though
life-cycle models with finitely-lived agents are becoming more common in
macroeconomics and are almost universal in household finance. The
implementation is almost identical in both cases, with the major
difference being that

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Infinite-horizon problems are solved by iteration until convergence
  (of the value or policy functions) starting from some initial guess.
\item
  Life-cycle problems are solved by backward induction, starting from
  the terminal period \(T\) and iterating backwards through periods
  \(T-1\), \(T-2\), \etc until the first period.
\end{enumerate}

Throughout this unit, we will exclusively solve partial equilibrium
problems for given prices (interest rates and wages). Solving for
general equilibrium would require us to find an additional fixed point
in terms of equilibrium prices (in steady-state models such as Aiyagari
(1994) or Huggett (1993)), or a equilibrium forecasting rule (for models
with aggregate uncertainty such as Krusell-Smith (1998)).

    For numerical purposes it is necessary to formulate the household
problem in recursive form. You may be more familiar with the sequential
formulation of an infinite horizon problem which could look something
like the following, \[
\begin{aligned}
V(a_0) &= \max_{(c_t,\,a_{t+1})_{t=0}^{\infty}}
\sum_{t=0}^{\infty} \beta^t u(c_t)  \\
\text{s.t.} \quad & c_t + a_{t+1} = (1+r)a_t + y_t \quad \forall~t \\
& c_t \geq 0,\; a_{t+1} \geq 0 \quad \forall~t
\end{aligned}
\] where the household chooses \emph{sequences} of consumption
\((c_t)_{t=0}^{\infty}\) and asset levels \((a_{t+1})_{t=0}^{\infty}\)
for some initial assets \(a_0\). The value function \(V\) is the maximum
over such sequences. However, when we solve a problem numerically on the
computer, it is usually more convenient to reformulate it recursively to
obtain \[
\begin{aligned}
V(a) = &\max_{c,\,a'}~\Bigl\{ u(c)
    + \beta V(a') \Bigr\} \\
    \text{s.t.} \quad &c + a' = (1+r)a  + y \\
    & c \geq 0,\; a' \geq 0
\end{aligned}
\] where the household picks optimal \emph{scalars} \(c\) and \(a'\) for
given \(a\) and parameters.

\emph{Note:} With recursive formulations we often use primes to denote
next-period values such as \(a'\) instead of writing \(t+1\) since time
\(t\) does not play any explicit role.


\hypertarget{vfi-with-deterministic-income}{%
\subsection{VFI with deterministic
income}\label{vfi-with-deterministic-income}}

    \hypertarget{household-problem}{%
\subsubsection{Household problem}\label{household-problem}}

For starters, consider the following \emph{deterministic}
infinite-horizon consumption-savings problem, \[
\begin{aligned}
V(a) = &\max_{c,\,a'} \left\{ 
    \frac{c^{1-\gamma} - 1}{1-\gamma}
    + \beta V(a') \right\} \\
    \text{s.t.} \quad &c + a' = (1+r)a  + y \\
    &c \geq 0,\; a' \geq 0
\end{aligned}
\] where \(a\) are beginning-of-period assets, and \(r\) and \(y\) are
the interest rate and labour earnings, respectively, which are both
exogenous. The household has CRRA utility and chooses optimal
consumption \(c\) and next-period assets \(a'\) which are required to be
non-negative (\ie we impose a borrowing constraint at 0).

Note that from a programming perspective we are interested in the case
when \(y > 0\) as otherwise this problem can be solved analytically (the
household consumes a constant fraction of its assets due to CRRA
preferences).

For \(y > 0\), this problem has to be solved numerically which we do
using \emph{value function iteration (VFI)}. VFI takes an initial guess
\(V_0\) and solves the above problem repeatedly, generating a sequence
of updated guesses \(V_n, V_{n+1}, \dots\). We terminate the algorithm
once consecutive \(V_n\) do not change anymore.

VFI itself does not dictate how the updated \(V\) is computed. In the
sections below we explore two alternatives:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  VFI combined with grid search; and
\item
  VFI combined with interpolation;
\end{enumerate}

    \hypertarget{vfi-with-grid-search}{%
\subsubsection{VFI with grid search}\label{vfi-with-grid-search}}

The simplest way to solve the above problem is to use the so-called
\emph{grid search} algorithm where we try all candidate savings levels
from a discrete set of choices (the \emph{grid}). Instead of picking an
arbitrary \(a' \in [0, (1+r)a + y]\), the household is thus constrained
to pick an element \(a' \in \Gamma_{a}\) from the pre-determined set of
\(N_a\) feasible asset levels \[
\Gamma_{a} = \Bigl\{a_1, a_1, a_2, \dots, a_{N_a} \Bigr\}
\] For convenience, we often use the grid \(\Gamma_a\) both as the set
of points for which we solve the problem numerically as well as the
household's choice set for \(a'\), thus forcing the household to pick a
point on the grid on which the problem is defined. This is not strictly
required (the household could in principle choose from an arbitrary
finite set), but allows us to skip any interpolation of the continuation
value function \(V(a')\).

While grid search is generally considered obsolete in modern
applications, it has a few distinct advantages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Easy to implement;
\item
  Does not require computing derivatives (even more, it does not assume
  differentiability);
\item
  Fast (unless the grid is very dense or there are many choices);
\end{enumerate}

However, we usually avoid it because of its disadvantages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  It's imprecise, and policy function are often not smooth (unless the
  grid is very dense);
\item
  Does not scale well to multiple choice dimensions;
\end{enumerate}

You might still have to resort to grid search if your problem is not
differentiable or has local maxima which breaks more sophisticated
solution methods.

    \hypertarget{outline-of-the-algorithm}{%
\subsubsection*{Outline of the algorithm}\label{outline-of-the-algorithm}}

The grid search algorithm for this problem can be summarized as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset grid \(\Gamma_a = (a_1, \dots, a_{N_a}).\)
\item
  Pick an initial guess \(V_0\) for the value function defined on
  \(\Gamma_a\).
\item
  In iteration \(n\), perform the following steps:

  For each asset level \(a_i\) at grid point \(i\),

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Find all feasible next-period asset levels \(a_j \in \Gamma_a\) that
    satisfy the budget constraint, \[a_j \leq (1+r)a_i + y\]
  \item
    For each \(j\), compute consumption: \[c_j = (1+r)a_i + y - a_j\]
  \item
    For each \(j\), compute utility: \[U_j = u(c_j) + \beta V_n(a_j)\]
  \item
    Find the index \(k\) that maximises the above expression:
    \[k = \argmax_{j} \Bigl\{ u(c_j) + \beta V_n(a_j)\Bigr\}\]
  \item
    Set \(V_{n+1,i} = U_k\) and store \(k\) as the optimal choice at
    \(i\).
  \end{enumerate}
\item
  Check for convergence: If \(\|V_n-V_{n+1}\| < \epsilon\), for some
  small tolerance \(\epsilon > 0\), exit the algorithm.
\end{enumerate}

We implement this algorithm below. For this level of complexity, we
would normally want to store the code as regular Python files
(\texttt{*.py}) as opposed to writing down the problem in a Jupyter
notebook. The complete implementation is therefore available in the
files

\begin{itemize}
\tightlist
\item
  \href{../lectures/unit11/main.py}{\texttt{lectures/unit11/main.py}}:
  sets up the problem, calls the VFI solver, plots results; and
\item
  \href{../lectures/unit11/VFI.py}{\texttt{lectures/unit11/VFI.py}}:
  implements VFI with grid search as well as with interpolation;
\end{itemize}

The sections below walk you through this implementation in notebook
format.

    \hypertarget{defining-parameters-and-grids}{%
\subsubsection*{Defining parameters and
grids}\label{defining-parameters-and-grids}}

For our implementation, we use the following parameters which are
standard in macroeconomics:

\begin{longtable}[]{@{}lll@{}}
\toprule
Parameter & Description & Value\tabularnewline
\midrule
\endhead
\(\beta\) & Discount factor & 0.96\tabularnewline
\(\gamma\) & Coef. of relative risk aversion & 2\tabularnewline
\(r\) & Interest rate & 0.04\tabularnewline
\(y\) & Labour income & 1\tabularnewline
\bottomrule
\end{longtable}

In Python, it is convenient to store all these parameters in a single
object so we don't have to pass numerous arguments to functions that
perform the actual computations. To this end, we define a class which
serves as a container object:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{dataclasses} \PY{k+kn}{import} \PY{n}{dataclass}

\PY{n+nd}{@dataclass}
\PY{k}{class} \PY{n+nc}{Parameters}\PY{p}{:}
\PY{+w}{    }\PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+sd}{    Define object to store model parameters and their default values}
\PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{beta} \PY{o}{=} \PY{l+m+mf}{0.96}         \PY{c+c1}{\PYZsh{} Discount factor}
    \PY{n}{gamma} \PY{o}{=} \PY{l+m+mf}{1.0}         \PY{c+c1}{\PYZsh{} Risk aversion}
    \PY{n}{y} \PY{o}{=} \PY{l+m+mf}{1.0}             \PY{c+c1}{\PYZsh{} Labour income}
    \PY{n}{r} \PY{o}{=} \PY{l+m+mf}{0.04}            \PY{c+c1}{\PYZsh{} Interest rate}
    \PY{n}{grid\PYZus{}a} \PY{o}{=} \PY{k+kc}{None}       \PY{c+c1}{\PYZsh{} Asset grid (to be created)}
\end{Verbatim}
\end{tcolorbox}

    The \texttt{@dataclass} decorator is a convenient short-hand to define
the attributes directly within the class body (we can safely ignore the
technical details).

\emph{Note:} Once our code becomes more complex, it is good practice to
document the purpose of a \texttt{class} or function using the
triple-quote doc strings \texttt{"""\ ...\ """}. These are ignored by
the Python interpreter.

    We use this class definition to create a \texttt{Parameters} instance
named \texttt{par} below. Additionally, we create the asset grid
\texttt{grid\_a} which we add to this object:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{n}{par} \PY{o}{=} \PY{n}{Parameters}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Start + end point for asset grid}
\PY{n}{a\PYZus{}min} \PY{o}{=} \PY{l+m+mf}{0.0}
\PY{n}{a\PYZus{}max} \PY{o}{=} \PY{l+m+mf}{10.0}
\PY{c+c1}{\PYZsh{} Number of grid points}
\PY{n}{N\PYZus{}a} \PY{o}{=} \PY{l+m+mi}{30}

\PY{c+c1}{\PYZsh{} Create asset grid with more points at the beginning}
\PY{n}{grid\PYZus{}a}  \PY{o}{=} \PY{n}{a\PYZus{}min} \PY{o}{+} \PY{p}{(}\PY{n}{a\PYZus{}max} \PY{o}{\PYZhy{}} \PY{n}{a\PYZus{}min}\PY{p}{)} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mf}{0.0}\PY{p}{,} \PY{l+m+mf}{1.0}\PY{p}{,} \PY{n}{N\PYZus{}a}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{1.5}

\PY{c+c1}{\PYZsh{} Store asset grid in Parameters object}
\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{=} \PY{n}{grid\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    Note the seemingly unconventional way to create the asset grid where we
first create a uniform grid on \([0, 1]\) and then compress the grid at
lower asset levels using an exponential transformation.

Alternatively, we could have created the usual uniformly-spaced grid:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{grid\PYZus{}a\PYZus{}uniform} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{n}{a\PYZus{}min}\PY{p}{,} \PY{n}{a\PYZus{}max}\PY{p}{,} \PY{n}{N\PYZus{}a}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    However, we know from experience that the value and policy functions
tend to be nonlinear for low assets, and therefore it is advantageous to
put more grid points in that region.

You can see the difference by plotting the resulting grids:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} Common arguments controlling plot style}
\PY{n}{style} \PY{o}{=} \PY{n+nb}{dict}\PY{p}{(}\PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{mfc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{none}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{alpha}\PY{o}{=}\PY{l+m+mf}{0.7}\PY{p}{,} \PY{n}{markersize}\PY{o}{=}\PY{l+m+mi}{4}\PY{p}{)}

\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{c}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{steelblue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Dense at low assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{o}{*}\PY{o}{*}\PY{n}{style}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{grid\PYZus{}a\PYZus{}uniform}\PY{p}{,} \PY{n}{c}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{darkred}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Uniform}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{o}{*}\PY{o}{*}\PY{n}{style}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Grid index}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Asset level}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{upper left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
<matplotlib.legend.Legend at 0x7ff91ed2b220>
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{unit11_files/unit11_14_1.pdf}
    \end{center}
    
    \hypertarget{implementing-vfi-with-grid-search}{%
\subsubsection*{Implementing VFI with grid
search}\label{implementing-vfi-with-grid-search}}

The following code implements the VFI algorithm with grid search. We
define the function

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ vfi\_grid(par, tol}\OperatorTok{=}\FloatTok{1e{-}5}\NormalTok{, maxiter}\OperatorTok{=}\DecValTok{1000}\NormalTok{):}
\NormalTok{    ...}
\end{Highlighting}
\end{Shaded}

which takes as arguments an instance of the \texttt{Parameters} class,
the termination tolerance \texttt{tol} and the maximum number of
iterations \texttt{maxiter}. The function creates a few arrays to hold
the intermediate and final results and then iterates on the value
function until convergence or until the maximum number of iterations is
exceeded.

Since the optimal savings choice has to lie on the asset grid, we
represent the savings policy function as an \emph{integer} array which
contains the \emph{indices} of the optimal asset level instead of the
asset level itself.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{vfi\PYZus{}grid}\PY{p}{(}\PY{n}{par}\PY{p}{,} \PY{n}{tol}\PY{o}{=}\PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,} \PY{n}{maxiter}\PY{o}{=}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
    
    \PY{n}{N\PYZus{}a} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}
    \PY{n}{vfun} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{N\PYZus{}a}\PY{p}{)}
    \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{n}{N\PYZus{}a}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} index of optimal savings decision (stored in integer array!)}
    \PY{n}{pfun\PYZus{}ia} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{n}{N\PYZus{}a}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{uint}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} pre\PYZhy{}compute cash at hand for each asset grid point}
    \PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{y}

    \PY{k}{for} \PY{n}{it} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{maxiter}\PY{p}{)}\PY{p}{:}

        \PY{k}{for} \PY{n}{ia}\PY{p}{,} \PY{n}{a} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{:}

            \PY{c+c1}{\PYZsh{} find all values of a\PYZsq{} that are feasible, ie. they satisfy}
            \PY{c+c1}{\PYZsh{} the budget constraint}
            \PY{n}{ia\PYZus{}to} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{cah}\PY{p}{[}\PY{n}{ia}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}

            \PY{c+c1}{\PYZsh{} consumption implied by choice a\PYZsq{}}
            \PY{c+c1}{\PYZsh{}   c = (1+r)a + y \PYZhy{} a\PYZsq{}}
            \PY{n}{cons} \PY{o}{=} \PY{n}{cah}\PY{p}{[}\PY{n}{ia}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{[}\PY{n}{ia\PYZus{}to}\PY{p}{]}

            \PY{c+c1}{\PYZsh{} Evaluate \PYZdq{}instantaneous\PYZdq{} utility}
            \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{gamma} \PY{o}{==} \PY{l+m+mf}{1.0}\PY{p}{:}
                \PY{n}{u} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{log}\PY{p}{(}\PY{n}{cons}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n}{u} \PY{o}{=} \PY{p}{(}\PY{n}{cons}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mf}{1.0}\PY{p}{)} \PY{o}{/} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{)}

            \PY{c+c1}{\PYZsh{} \PYZsq{}candidate\PYZsq{} value for each choice a\PYZsq{}}
            \PY{n}{v\PYZus{}cand} \PY{o}{=} \PY{n}{u} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{beta} \PY{o}{*} \PY{n}{vfun}\PY{p}{[}\PY{n}{ia\PYZus{}to}\PY{p}{]}

            \PY{c+c1}{\PYZsh{} find the \PYZsq{}candidate\PYZsq{} a\PYZsq{} which maximises utility}
            \PY{n}{ia\PYZus{}to\PYZus{}max} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{argmax}\PY{p}{(}\PY{n}{v\PYZus{}cand}\PY{p}{)}

            \PY{c+c1}{\PYZsh{} store results for next iteration}
            \PY{n}{v\PYZus{}opt} \PY{o}{=} \PY{n}{v\PYZus{}cand}\PY{p}{[}\PY{n}{ia\PYZus{}to\PYZus{}max}\PY{p}{]}
            \PY{n}{vfun\PYZus{}upd}\PY{p}{[}\PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{v\PYZus{}opt}
            \PY{n}{pfun\PYZus{}ia}\PY{p}{[}\PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{ia\PYZus{}to\PYZus{}max}

        \PY{n}{diff} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{vfun} \PY{o}{\PYZhy{}} \PY{n}{vfun\PYZus{}upd}\PY{p}{)}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} switch references to value functions for next iteration}
        \PY{n}{vfun}\PY{p}{,} \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{vfun\PYZus{}upd}\PY{p}{,} \PY{n}{vfun}

        \PY{k}{if} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{n}{tol}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Converged after }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations: dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
            \PY{k}{break}
        \PY{k}{elif} \PY{n}{it} \PY{o}{==} \PY{l+m+mi}{1} \PY{o+ow}{or} \PY{n}{it} \PY{o}{\PYZpc{}} \PY{l+m+mi}{50} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Iteration }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Did not converge in }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations}\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}

    \PY{k}{return} \PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}ia}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{running-the-solver}{%
\subsubsection*{Running the solver}\label{running-the-solver}}

We are now ready to run the VFI. Note that the second return value is an
array of \emph{indices} and hence we first need to recover the
associated asset levels to get proper savings policy function. The
consumption policy function can then be recovered from the budget
constraint.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}ia} \PY{o}{=} \PY{n}{vfi\PYZus{}grid}\PY{p}{(}\PY{n}{par}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Recover savings policy function from optimal asset indices}
\PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{[}\PY{n}{pfun\PYZus{}ia}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Recover consumption policy function from budget constraint}
\PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{y}
\PY{n}{pfun\PYZus{}c} \PY{o}{=} \PY{n}{cah} \PY{o}{\PYZhy{}} \PY{n}{pfun\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
VFI: Iteration   0, dV=2.43e+00
VFI: Iteration   1, dV=1.17e+00
VFI: Iteration  50, dV=8.31e-03
VFI: Iteration 100, dV=1.08e-03
VFI: Iteration 150, dV=1.40e-04
VFI: Iteration 200, dV=1.82e-05
VFI: Converged after 215 iterations: dV=9.87e-06
    \end{Verbatim}

    Finally, it i always a good idea to visualise the results to get some
economic intuition and spot errors.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{fig}\PY{p}{,} \PY{n}{axes} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{sharex}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{sharey}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot savings in first column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}a}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Savings \PYZdl{}a\PYZca{}}\PY{l+s+s1}{\PYZob{}}\PY{l+s+s1}{\PYZbs{}}\PY{l+s+s1}{prime\PYZcb{}\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot consumption in second column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Consumption \PYZdl{}c\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot value function in third column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{vfun}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value func. \PYZdl{}V\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Text(0.5, 0, 'Assets')
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{unit11_files/unit11_20_1.pdf}
    \end{center}
    
    The above plot suggests that there is a jump in the consumption policy
function for low assets. There is no economic reason why this should be
the case, and in fact this is an undesirable artifact of grid search.
Such artifacts may appear for some choices of the asset grid, as is the
case here. This is one of the reason why we usually prefer other
solution methods that do not exhibit this behaviour, such as VFI with
interpolation, which we turn to next.

    \hypertarget{vfi-with-interpolation}{%
\subsubsection{VFI with interpolation}\label{vfi-with-interpolation}}

In the previous section, we saw how grid search can give rise to
undesired numerical artifacts that misrepresent the solution. Moreover,
unless our grid is extremely dense, the solution is unlikely to satisfy
the first-order optimality conditions because the optimal \(a'\) need
not be on the candidate grid.

A more advanced solution method is to combine VFI with interpolation of
the continuation value paired with a maximisation step, which we explore
in this section. The advantages of this method are

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The solution is ``exact'' in a numerical sense.
\item
  It is less affected by the curse of dimensionality with many
  (continuous) choice variables.
\item
  It is easier to spot mistakes because the resulting policy functions
  tend to be smooth.
\end{enumerate}

On the other hand, this method

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Is likely to be slower than grid search; and
\item
  Is more complex to implement because we need an additional numerical
  maximisation routine which might require computing (numerical)
  derivatives.
\end{enumerate}

    \hypertarget{outline-of-the-algorithm}{%
\subsubsection*{Outline of the algorithm}\label{outline-of-the-algorithm}}

To implement VFI with interpolation, we need to modify the original
algorithm as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset grid \(\Gamma_a = (a_1, \dots, a_{N_a})\).
\item
  Pick an initial guess \(V_0\) for value function defined on
  \(\Gamma_a\).
\item
  In iteration \(n\), perform the following steps:

  For each asset level \(a_i\) at grid point \(i\),

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Compute the available resources (cash at hand):
    \[x_{i} = (1+r)a_i + y\]
  \item
    Find the maximiser
    \[a^{\star} = \argmax_{a' \in [0, x_{i}]} \Bigl\{ u\left(x_{i}-a'\right) + \beta V_n(a') \Bigr\}\]
    This step is usually performed using a numerical maximisation (or
    minimisation) routine.
  \item
    The value \(V^{\star}\) is then given by
    \[V^{\star} = u\left(x_{ij}-a^{\star}\right) + \beta V_n(a^{\star})\]
  \item
    Store the updated value \(V_{n+1,i} = V^{\star}\) and the associated
    savings policy function.
  \end{enumerate}
\item
  Check for convergence: If \(\|V_n-V_{n+1}\| < \epsilon\), for some
  small tolerance \(\epsilon > 0\), exit the algorithm.
\end{enumerate}

Note that we still solve the problem on a grid \((a_1, \dots, a_{N_a})\)
but we no longer require households to make savings choices exactly on
this grid.

    \hypertarget{implementing-vfi-with-interpolation}{%
\subsubsection*{Implementing VFI with
interpolation}\label{implementing-vfi-with-interpolation}}

As before, the full implementation is provided in the Python script
files
\href{../lectures/unit11/main.py}{\texttt{lectures/unit11/main.py}} and
\href{../lectures/unit11/VFI.py}{\texttt{lectures/unit11/VFI.py}}.

To perform the maximisation step, we need to define an objective
function that can be passed to a minimiser such as SciPy's
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html}{\texttt{minimize\_scalar()}}.
For the problem at hand, we define this objective function as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ f\_objective(sav, cah, par, f\_vfun):}
\NormalTok{    ...}
\end{Highlighting}
\end{Shaded}

where \texttt{sav} is the candidate savings level \(a'\), \texttt{cah}
is the cash-at-hand at the current point \(a_i\), \texttt{par} is the
\texttt{Parameters} instance and \texttt{f\_vfun} is a callable function
that can be used to evaluate the continuation value \(V_n(a')\) using
interpolation. The implementation of this function looks as follows:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{f\PYZus{}objective}\PY{p}{(}\PY{n}{sav}\PY{p}{,} \PY{n}{cah}\PY{p}{,} \PY{n}{par}\PY{p}{,} \PY{n}{f\PYZus{}vfun}\PY{p}{)}\PY{p}{:}

    \PY{n}{sav} \PY{o}{=} \PY{n+nb}{float}\PY{p}{(}\PY{n}{sav}\PY{p}{)}
    \PY{k}{if} \PY{n}{sav} \PY{o}{\PYZlt{}} \PY{l+m+mf}{0.0} \PY{o+ow}{or} \PY{n}{sav} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n}{cah}\PY{p}{:}
        \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{inf}

    \PY{c+c1}{\PYZsh{} Consumption implied by savings level}
    \PY{n}{cons} \PY{o}{=} \PY{n}{cah} \PY{o}{\PYZhy{}} \PY{n}{sav}

    \PY{c+c1}{\PYZsh{} Continuation value interpolated onto asset grid}
    \PY{n}{vcont} \PY{o}{=} \PY{n}{f\PYZus{}vfun}\PY{p}{(}\PY{n}{sav}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} evaluate \PYZdq{}instantaneous\PYZdq{} utility}
    \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{gamma} \PY{o}{==} \PY{l+m+mf}{1.0}\PY{p}{:}
        \PY{n}{u} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{log}\PY{p}{(}\PY{n}{cons}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{u} \PY{o}{=} \PY{p}{(}\PY{n}{cons}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mf}{1.0}\PY{p}{)} \PY{o}{/} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Objective evaluated at current savings level}
    \PY{n}{obj} \PY{o}{=} \PY{n}{u} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{beta} \PY{o}{*} \PY{n}{vcont}

    \PY{c+c1}{\PYZsh{} We are running a minimiser, return negative of objective value}
    \PY{k}{return} \PY{o}{\PYZhy{}}\PY{n}{obj}
\end{Verbatim}
\end{tcolorbox}

    Because we are going to call this objective function from a minimiser,
we need to return the negative utility as shown in the last line.

Now that we have the objective function, VFI with interpolation is
implemented by the following function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize\PYZus{}scalar}

\PY{k}{def} \PY{n+nf}{vfi\PYZus{}interp}\PY{p}{(}\PY{n}{par}\PY{p}{,} \PY{n}{tol}\PY{o}{=}\PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,} \PY{n}{maxiter}\PY{o}{=}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}

    \PY{n}{N\PYZus{}a} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}
    \PY{n}{vfun} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{N\PYZus{}a}\PY{p}{)}
    \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{n}{N\PYZus{}a}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Optimal savings decision}
    \PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{N\PYZus{}a}\PY{p}{)}

    \PY{k}{for} \PY{n}{it} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{maxiter}\PY{p}{)}\PY{p}{:}

        \PY{c+c1}{\PYZsh{} Define function that interpolates continuation value}
        \PY{n}{f\PYZus{}vfun} \PY{o}{=} \PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{np}\PY{o}{.}\PY{n}{interp}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{vfun}\PY{p}{)}

        \PY{k}{for} \PY{n}{ia}\PY{p}{,} \PY{n}{a} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Solve maximization problem at given asset level}
            \PY{c+c1}{\PYZsh{} Cash\PYZhy{}at\PYZhy{}hand at current asset level}
            \PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{a} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{y}
            \PY{c+c1}{\PYZsh{} Restrict maximisation to following interval:}
            \PY{n}{bounds} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{0.0}\PY{p}{,} \PY{n}{cah}\PY{p}{)}
            \PY{c+c1}{\PYZsh{} Arguments to be passed to objective function}
            \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{n}{cah}\PY{p}{,} \PY{n}{par}\PY{p}{,} \PY{n}{f\PYZus{}vfun}\PY{p}{)}
            \PY{c+c1}{\PYZsh{} perform maximisation}
            \PY{n}{res} \PY{o}{=} \PY{n}{minimize\PYZus{}scalar}\PY{p}{(}\PY{n}{f\PYZus{}objective}\PY{p}{,} \PY{n}{bracket}\PY{o}{=}\PY{n}{bounds}\PY{p}{,} \PY{n}{args}\PY{o}{=}\PY{n}{args}\PY{p}{)}

            \PY{c+c1}{\PYZsh{} Minimiser returns NEGATIVE utility, revert that}
            \PY{n}{vfun\PYZus{}upd}\PY{p}{[}\PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{o}{\PYZhy{}} \PY{n}{res}\PY{o}{.}\PY{n}{fun}
            \PY{c+c1}{\PYZsh{} Store optimal savings a\PYZsq{}}
            \PY{n}{pfun\PYZus{}a}\PY{p}{[}\PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{res}\PY{o}{.}\PY{n}{x}

        \PY{n}{diff} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{vfun} \PY{o}{\PYZhy{}} \PY{n}{vfun\PYZus{}upd}\PY{p}{)}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} switch references to value functions for next iteration}
        \PY{n}{vfun}\PY{p}{,} \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{vfun\PYZus{}upd}\PY{p}{,} \PY{n}{vfun}

        \PY{k}{if} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{n}{tol}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Converged after }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations: dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
            \PY{k}{break}
        \PY{k}{elif} \PY{n}{it} \PY{o}{==} \PY{l+m+mi}{1} \PY{o+ow}{or} \PY{n}{it} \PY{o}{\PYZpc{}} \PY{l+m+mi}{50} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Iteration }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Did not converge in }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations}\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}

    \PY{k}{return} \PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{running-the-solver}{%
\subsubsection*{Running the solver}\label{running-the-solver}}

We run the solver in the same way as we did with grid search, except
that now the function returns an array of optimal savings \emph{levels},
not the indices on the grid. We therefore no longer need to recover the
actual savings policy function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{vfi\PYZus{}interp}\PY{p}{(}\PY{n}{par}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Recover consumption policy function from budget constraint}
\PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{y}
\PY{n}{pfun\PYZus{}c} \PY{o}{=} \PY{n}{cah} \PY{o}{\PYZhy{}} \PY{n}{pfun\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/richard/.conda/envs/python-intro-PGR/lib/python3.10/site-
packages/scipy/optimize/\_optimize.py:2417: RuntimeWarning: invalid value
encountered in scalar multiply
  tmp2 = (x - v) * (fx - fw)
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
VFI: Iteration   0, dV=2.43e+00
VFI: Iteration   1, dV=1.17e+00
VFI: Iteration  50, dV=6.39e-03
VFI: Iteration 100, dV=4.35e-04
VFI: Iteration 150, dV=2.96e-05
VFI: Converged after 170 iterations: dV=9.57e-06
    \end{Verbatim}

    Visualising the solution, we see that the artifacts in the consumption
policy function are no longer present.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{fig}\PY{p}{,} \PY{n}{axes} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{sharex}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{sharey}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot savings in first column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}a}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Savings \PYZdl{}a\PYZca{}}\PY{l+s+s1}{\PYZob{}}\PY{l+s+s1}{\PYZbs{}}\PY{l+s+s1}{prime\PYZcb{}\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot consumption in second column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Consumption \PYZdl{}c\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot value function in third column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{vfun}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value func. \PYZdl{}V\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Text(0.5, 0, 'Assets')
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{unit11_files/unit11_31_1.pdf}
    \end{center}
    

\hypertarget{vfi-with-stochastic-labour-income}{%
\subsection{VFI with stochastic labour
income}\label{vfi-with-stochastic-labour-income}}

\hypertarget{modelling-stochastic-labour-income}{%
\subsubsection{Modelling stochastic labour
income}\label{modelling-stochastic-labour-income}}

So far, we assumed that labour income \(y\) was deterministic and
constant. In more realistic heterogeneous-agent models in macroeconomics
and household finance, we instead model labour income as stochastic and
thus risky. One frequent assumption is that labour income follows an
AR(1) process in logs, \ie \[
\begin{aligned}
    \log y_{t+1} &= \rho \log y_t + \nu_{t+1} \\
    \nu_{t+1} &\stackrel{\text{iid}}{\sim} N(0, \sigma^2)
\end{aligned}
\] The corresponding household problem is then given by \[
\begin{aligned}
V(y,a) = &\max_{c,\,a'}~\Bigl\{ u(c)
    + \beta \mathbb{E}\bigl[\left.V(y',a')~\right|~ y\bigr] \Bigr\} \\
    \text{s.t.} \quad &c + a' = (1+r)a  + y \\
    & c \geq 0,\; a' \geq 0
\end{aligned}
\] where we added the additional state variable \(y\) and need to take
expectations over future realisations of \(y'\).

There are two commonly-used approaches to incorporate such an income
process into our household problem:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Assume that \(y\) is a continuous state variable and use
  \href{https://en.wikipedia.org/wiki/Gauss\%E2\%80\%93Hermite_quadrature}{Gauss-Hermite
  quadrature} to compute expectations.
\item
  Discretize \(y\) to take on a few selected values and model it as a
  Markov chain on the discretised state space.
\end{enumerate}

We will following the second approach in this unit. Two common
algorithms to ``convert'' an AR(1) into a Markov chain are the Tauchen
and the Rouwenhorst methods. The latter seems to be preferable when
dealing with highly persistent processes such as labour income. The
discretised labour income process with \(N_y\) grid points is then given
by the states \(\Gamma_y = (y_1,\dots,y_{N_y})\) and the transition
matrix \(\Pi_y\) with typical element \[
\Pi_y(i,j) = \text{Pr}\bigl[y_{t+1} = y_j~|~y_t = y_i\bigr]~.
\]

We use the function \texttt{rouwenhorst()} defined below to perform this
mapping for us. Its arguments are the number of nodes of the discretized
state space \texttt{n}, the mean of the AR(1) process \texttt{mu}, the
autocorrelation parameter \texttt{rho} and the conditional standard
deviation \texttt{sigma} (see the file
\href{../lectures/unit11/markov.py}{\texttt{lectures/unit11/markov.py}}
for a complete implementation which includes error checking of input
arguments). There is no need to understand the details of this function
as we are only interested in using its return values: the state space
stored in the vector \texttt{z} and the transition matrix \texttt{Pi}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{k}{def} \PY{n+nf}{rouwenhorst}\PY{p}{(}\PY{n}{n}\PY{p}{,} \PY{n}{mu}\PY{p}{,} \PY{n}{rho}\PY{p}{,} \PY{n}{sigma}\PY{p}{)}\PY{p}{:}
    
    \PY{n}{p} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{o}{+}\PY{n}{rho}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}
    \PY{n}{Pi} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{n}{p}\PY{p}{,} \PY{l+m+mi}{1}\PY{o}{\PYZhy{}}\PY{n}{p}\PY{p}{]}\PY{p}{,} \PY{p}{[}\PY{l+m+mi}{1}\PY{o}{\PYZhy{}}\PY{n}{p}\PY{p}{,} \PY{n}{p}\PY{p}{]}\PY{p}{]}\PY{p}{)}

    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{Pi}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{n}\PY{p}{)}\PY{p}{:}
        \PY{n}{tmp} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{pad}\PY{p}{(}\PY{n}{Pi}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{mode}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{constant}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{constant\PYZus{}values}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
        \PY{n}{Pi} \PY{o}{=} \PY{n}{p} \PY{o}{*} \PY{n}{tmp}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]} \PY{o}{+} \PY{p}{(}\PY{l+m+mi}{1}\PY{o}{\PYZhy{}}\PY{n}{p}\PY{p}{)} \PY{o}{*} \PY{n}{tmp}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{,} \PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{+} \PYZbs{}
             \PY{p}{(}\PY{l+m+mi}{1}\PY{o}{\PYZhy{}}\PY{n}{p}\PY{p}{)} \PY{o}{*} \PY{n}{tmp}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]} \PY{o}{+} \PY{n}{p} \PY{o}{*} \PY{n}{tmp}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
        \PY{n}{Pi}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{p}{:}\PY{p}{]} \PY{o}{/}\PY{o}{=} \PY{l+m+mi}{2}

    \PY{n}{fi} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{*} \PY{n}{sigma} \PY{o}{/} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{l+m+mi}{1} \PY{o}{\PYZhy{}} \PY{n}{rho} \PY{o}{*}\PY{o}{*} \PY{l+m+mi}{2}\PY{p}{)}
    \PY{n}{z} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{fi}\PY{p}{,} \PY{n}{fi}\PY{p}{,} \PY{n}{n}\PY{p}{)} \PY{o}{+} \PY{n}{mu}

    \PY{k}{return} \PY{n}{z}\PY{p}{,} \PY{n}{Pi}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{model-parameters}{%
\subsubsection*{Model parameters}\label{model-parameters}}

Since the household problem with stochastic labour income has a few more
parameters, we redefine the \texttt{Parameters} class from earlier to
include these. The additional parameters are listed in the table below.
The values for the AR(1) labour income process are standard and taken
from papers such as Aiyagari (1994).

\begin{longtable}[]{@{}lll@{}}
\toprule
Parameter & Description & Value\tabularnewline
\midrule
\endhead
\(\beta\) & Discount factor & 0.96\tabularnewline
\(\gamma\) & Coef. of relative risk aversion & 2\tabularnewline
\(r\) & Interest rate & 0.04\tabularnewline
\(\rho\) & Autocorrelation of labour income & 0.95\tabularnewline
\(\sigma\) & Conditional std. dev. of labour income &
0.20\tabularnewline
\(N_y\) & Number of states for Markov chain & 3\tabularnewline
\bottomrule
\end{longtable}

    The updated definition of \texttt{Parameters} now looks as follows:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@dataclass}
\PY{k}{class} \PY{n+nc}{Parameters}\PY{p}{:}
\PY{+w}{    }\PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+sd}{    Define object to store model parameters and their default values}
\PY{l+s+sd}{    \PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{beta} \PY{o}{=} \PY{l+m+mf}{0.96}         \PY{c+c1}{\PYZsh{} Discount factor}
    \PY{n}{gamma} \PY{o}{=} \PY{l+m+mf}{1.0}         \PY{c+c1}{\PYZsh{} Risk aversion}
    \PY{n}{r} \PY{o}{=} \PY{l+m+mf}{0.04}            \PY{c+c1}{\PYZsh{} Interest rate}
    \PY{n}{rho} \PY{o}{=} \PY{l+m+mf}{0.95}          \PY{c+c1}{\PYZsh{} Autocorrelation of log labour income}
    \PY{n}{sigma} \PY{o}{=} \PY{l+m+mf}{0.20}        \PY{c+c1}{\PYZsh{} Conditional standard deviation of log labour income}
    \PY{n}{grid\PYZus{}a} \PY{o}{=} \PY{k+kc}{None}       \PY{c+c1}{\PYZsh{} Asset grid (to be created)}
    \PY{n}{grid\PYZus{}y} \PY{o}{=} \PY{k+kc}{None}       \PY{c+c1}{\PYZsh{} Discretised labour income grid (to be created)}
    \PY{n}{tm\PYZus{}y} \PY{o}{=} \PY{k+kc}{None}         \PY{c+c1}{\PYZsh{} Labour transition matrix (to be created)}
\end{Verbatim}
\end{tcolorbox}

    We can use the above function to create a discretised representation of
the risky labour income. For illustrative purposes we choose to
discretise \(y\) to only three points which would be considered too few
for realistic models.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{par} \PY{o}{=} \PY{n}{Parameters}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Number of labour grid points}
\PY{n}{N\PYZus{}y} \PY{o}{=} \PY{l+m+mi}{3}

\PY{c+c1}{\PYZsh{} Discretise labour income process (assume zero mean in logs)}
\PY{n}{states}\PY{p}{,} \PY{n}{tm\PYZus{}y} \PY{o}{=} \PY{n}{rouwenhorst}\PY{p}{(}\PY{n}{N\PYZus{}y}\PY{p}{,} \PY{n}{mu}\PY{o}{=}\PY{l+m+mf}{0.0}\PY{p}{,} \PY{n}{rho}\PY{o}{=}\PY{n}{par}\PY{o}{.}\PY{n}{rho}\PY{p}{,} \PY{n}{sigma}\PY{o}{=}\PY{n}{par}\PY{o}{.}\PY{n}{sigma}\PY{p}{)}

\PY{c+c1}{\PYZsh{} State space in levels}
\PY{n}{grid\PYZus{}y} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{n}{states}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Store labour grid and transition matrix}
\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y} \PY{o}{=} \PY{n}{grid\PYZus{}y}
\PY{n}{par}\PY{o}{.}\PY{n}{tm\PYZus{}y} \PY{o}{=} \PY{n}{tm\PYZus{}y}
\end{Verbatim}
\end{tcolorbox}

    Note that because stochastic income is log-normal and has zero mean in
logs, due to the properties of the log-normal distribution the average
income in \emph{levels} in the cross-section of households is given by
\[
\mathbb{E}[y] = \exp\left(\frac{1}{2}\sigma_{\nu}^2\right) > 1 
\] This is often undesirable as we'd like to normalise average income in
the economy to unity since this makes interpreting magnitudes easier. We
can achieve this by computing the ergodic (stationary) distribution of
labour using the following function (see also
\href{../lectures/unit11/markov.py}{\texttt{lectures/unit11/markov.py}}
for a complete implementation). Again, there is no need to understand
what this function does, we are only interested in the stationary
distribution it returns in the vector \texttt{mu}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy}\PY{n+nn}{.}\PY{n+nn}{linalg}

\PY{k}{def} \PY{n+nf}{markov\PYZus{}ergodic\PYZus{}dist}\PY{p}{(}\PY{n}{transm}\PY{p}{)}\PY{p}{:}
    \PY{n}{transm} \PY{o}{=} \PY{n}{transm}\PY{o}{.}\PY{n}{transpose}\PY{p}{(}\PY{p}{)}
    \PY{n}{m} \PY{o}{=} \PY{n}{transm} \PY{o}{\PYZhy{}} \PY{n}{np}\PY{o}{.}\PY{n}{identity}\PY{p}{(}\PY{n}{transm}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
    \PY{n}{m}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{n}{m} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{inv}\PY{p}{(}\PY{n}{m}\PY{p}{)}
    \PY{n}{mu} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{ascontiguousarray}\PY{p}{(}\PY{n}{m}\PY{p}{[}\PY{p}{:}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{k}{assert} \PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{mu}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZlt{}} \PY{l+m+mf}{1e\PYZhy{}9}
    \PY{n}{mu} \PY{o}{/}\PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{n}{mu}\PY{p}{)}
    \PY{k}{return} \PY{n}{mu}
\end{Verbatim}
\end{tcolorbox}

    We use this function to compute the ergodic distribution \texttt{edist}
implied by the Markov chain transition matrix. We can then use this
distribution to compute expectation \(\mathbb{E}[y]\) and we normalise
the state space by this value.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Ergodic distribution of labour income}
\PY{n}{edist} \PY{o}{=} \PY{n}{markov\PYZus{}ergodic\PYZus{}dist}\PY{p}{(}\PY{n}{tm\PYZus{}y}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Non\PYZhy{}normalised mean of labour income}
\PY{n}{mean} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{edist}\PY{p}{,} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Normalise states such that unconditional expectation is 1.0}
\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y} \PY{o}{/}\PY{o}{=} \PY{n}{mean}
\end{Verbatim}
\end{tcolorbox}

    Finally, we complete the setup of the problem by re-creating the asset
grid in the same way we did above.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Start + end point for asset grid}
\PY{n}{a\PYZus{}min} \PY{o}{=} \PY{l+m+mf}{0.0}
\PY{n}{a\PYZus{}max} \PY{o}{=} \PY{l+m+mf}{10.0}
\PY{c+c1}{\PYZsh{} Number of grid points}
\PY{n}{N\PYZus{}a} \PY{o}{=} \PY{l+m+mi}{30}

\PY{c+c1}{\PYZsh{} Create asset grid with more points at the beginning}
\PY{n}{grid\PYZus{}a}  \PY{o}{=} \PY{n}{a\PYZus{}min} \PY{o}{+} \PY{p}{(}\PY{n}{a\PYZus{}max} \PY{o}{\PYZhy{}} \PY{n}{a\PYZus{}min}\PY{p}{)} \PY{o}{*} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mf}{0.0}\PY{p}{,} \PY{l+m+mf}{1.0}\PY{p}{,} \PY{n}{N\PYZus{}a}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{1.5}

\PY{c+c1}{\PYZsh{} Store asset grid in Parameters object}
\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{=} \PY{n}{grid\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{vfi-with-grid-search}{%
\subsubsection{VFI with grid search}\label{vfi-with-grid-search}}

Before turning to the actual implementation, it is instructive to look
at the modified grid search algorithm for the case of risky labour
income. The main difference is that we now have an additional state
variable \(y\) and need to take care of expectations.

\hypertarget{outline-of-the-algorithm}{%
\subsubsection*{Outline of the algorithm}\label{outline-of-the-algorithm}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset grid \(\Gamma_a = (a_1, \dots, a_{N_a})\).
\item
  Create a discretised labour income process with states
  \(\Gamma_y = (y_1, \dots, y_{N_y})\) and transition matrix \(\Pi_y\).
\item
  Pick an initial guess \(V_0\) for the value function defined on
  \(\Gamma_y \times \Gamma_a\).
\item
  In iteration \(n\), perform the following steps:

  For each labour income \(y_i\) at index \(i\),

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Compute the expectation over labour income realisations \(y'\) given
    \(y_i\),
    \[ \widetilde{V}(a') = \mathbb{E}\bigl[V_n(y',a')~|~y_i \bigr]\]
    using the \(i\)-th row of the transition matrix \(\Pi_y\).
  \item
    For each asset level \(a_j\) at grid point \(j\),

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \tightlist
    \item
      Find all feasible next-period asset levels \(a_k \in \Gamma_a\)
      that satisfy the budget constraint \[a_k \leq (1+r)a_j + y_i\]
    \item
      For each \(k\), compute consumption
      \[c_{k} = (1+r)a_j + y_i - a_k\]
    \item
      For each \(k\), compute utility
      \[U_k = u(c_k) + \beta \widetilde{V}(a_k)\]
    \item
      Find the index \(\ell\) that maximises the above expression:
      \[\ell = \argmax_{k} \Bigl\{ u(c_k) + \beta \widetilde{V}(a_k)\Bigr\}\]
    \item
      Set \(V_{n+1,ij} = U_\ell\) and store \(\ell\) as the optimal
      choice at \((i,j)\)
    \end{enumerate}
  \end{enumerate}
\item
  Check for convergence: If \(\|V_n-V_{n+1}\| < \epsilon\), for some
  small tolerance \(\epsilon > 0\), exit the algorithm.
\end{enumerate}

    \hypertarget{implementing-vfi-with-grid-search}{%
\subsubsection*{Implementing VFI with grid
search}\label{implementing-vfi-with-grid-search}}

The following code implements VFI with risky labour income using grid
search (the code can also be found in
\href{../lectures/unit11/VFI_risk.py}{\texttt{lectures/unit11/VFI\_risk.py}}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{vfi\PYZus{}grid}\PY{p}{(}\PY{n}{par}\PY{p}{,} \PY{n}{tol}\PY{o}{=}\PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,} \PY{n}{maxiter}\PY{o}{=}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
    
    \PY{n}{N\PYZus{}a}\PY{p}{,} \PY{n}{N\PYZus{}y} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{)}
    \PY{n}{shape} \PY{o}{=} \PY{p}{(}\PY{n}{N\PYZus{}y}\PY{p}{,} \PY{n}{N\PYZus{}a}\PY{p}{)}
    \PY{n}{vfun} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{shape}\PY{p}{)}
    \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{n}{shape}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} index of optimal savings decision}
    \PY{n}{pfun\PYZus{}ia} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{n}{shape}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{uint}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} pre\PYZhy{}compute cash at hand for each (asset, labour) grid point}
    \PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{[}\PY{k+kc}{None}\PY{p}{]} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{k+kc}{None}\PY{p}{]}

    \PY{k}{for} \PY{n}{it} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{maxiter}\PY{p}{)}\PY{p}{:}

        \PY{c+c1}{\PYZsh{} Compute expected continuation value E[V(y\PYZsq{},a\PYZsq{})|y] for each (y,a\PYZsq{})}
        \PY{n}{EV} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{tm\PYZus{}y}\PY{p}{,} \PY{n}{vfun}\PY{p}{)}

        \PY{k}{for} \PY{n}{iy} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N\PYZus{}y}\PY{p}{)}\PY{p}{:}
            \PY{k}{for} \PY{n}{ia}\PY{p}{,} \PY{n}{a} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{:}

                \PY{c+c1}{\PYZsh{} find all values of a\PYZsq{} that are feasible, ie. they satisfy}
                \PY{c+c1}{\PYZsh{} the budget constraint}
                \PY{n}{ia\PYZus{}to} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{cah}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}

                \PY{c+c1}{\PYZsh{} consumption implied by choice a\PYZsq{}}
                \PY{c+c1}{\PYZsh{}   c = (1+r)a + y \PYZhy{} a\PYZsq{}}
                \PY{n}{cons} \PY{o}{=} \PY{n}{cah}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{[}\PY{n}{ia\PYZus{}to}\PY{p}{]}

                \PY{c+c1}{\PYZsh{} Evaluate \PYZdq{}instantaneous\PYZdq{} utility}
                \PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{gamma} \PY{o}{==} \PY{l+m+mf}{1.0}\PY{p}{:}
                    \PY{n}{u} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{log}\PY{p}{(}\PY{n}{cons}\PY{p}{)}
                \PY{k}{else}\PY{p}{:}
                    \PY{n}{u} \PY{o}{=} \PY{p}{(}\PY{n}{cons}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{l+m+mf}{1.0}\PY{p}{)} \PY{o}{/} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{\PYZhy{}} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{)}

                \PY{c+c1}{\PYZsh{} \PYZsq{}candidate\PYZsq{} value for each choice a\PYZsq{}}
                \PY{n}{v\PYZus{}cand} \PY{o}{=} \PY{n}{u} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{beta} \PY{o}{*} \PY{n}{EV}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia\PYZus{}to}\PY{p}{]}

                \PY{c+c1}{\PYZsh{} find the \PYZsq{}candidate\PYZsq{} a\PYZsq{} which maximizes utility}
                \PY{n}{ia\PYZus{}to\PYZus{}max} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{argmax}\PY{p}{(}\PY{n}{v\PYZus{}cand}\PY{p}{)}

                \PY{c+c1}{\PYZsh{} store results for next iteration}
                \PY{n}{v\PYZus{}opt} \PY{o}{=} \PY{n}{v\PYZus{}cand}\PY{p}{[}\PY{n}{ia\PYZus{}to\PYZus{}max}\PY{p}{]}
                \PY{n}{vfun\PYZus{}upd}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{v\PYZus{}opt}
                \PY{n}{pfun\PYZus{}ia}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{ia\PYZus{}to\PYZus{}max}

        \PY{n}{diff} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{vfun} \PY{o}{\PYZhy{}} \PY{n}{vfun\PYZus{}upd}\PY{p}{)}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} switch references to value functions for next iteration}
        \PY{n}{vfun}\PY{p}{,} \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{vfun\PYZus{}upd}\PY{p}{,} \PY{n}{vfun}

        \PY{k}{if} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{n}{tol}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Converged after }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations: dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
            \PY{k}{break}
        \PY{k}{elif} \PY{n}{it} \PY{o}{==} \PY{l+m+mi}{1} \PY{o+ow}{or} \PY{n}{it} \PY{o}{\PYZpc{}} \PY{l+m+mi}{50} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Iteration }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Did not converge in }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations}\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}

    \PY{k}{return} \PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}ia}
\end{Verbatim}
\end{tcolorbox}

    We can now run and plot the solution as we did in the case of
deterministic income.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}ia} \PY{o}{=} \PY{n}{vfi\PYZus{}grid}\PY{p}{(}\PY{n}{par}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Recover savings policy function from optimal asset indices}
\PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{[}\PY{n}{pfun\PYZus{}ia}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Recover consumption policy function from budget constraint}
\PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{[}\PY{p}{:}\PY{p}{,} \PY{k+kc}{None}\PY{p}{]}
\PY{n}{pfun\PYZus{}c} \PY{o}{=} \PY{n}{cah} \PY{o}{\PYZhy{}} \PY{n}{pfun\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
VFI: Iteration   0, dV=2.52e+00
VFI: Iteration   1, dV=1.38e+00
VFI: Iteration  50, dV=3.02e-02
VFI: Iteration 100, dV=2.07e-03
VFI: Iteration 150, dV=2.29e-04
VFI: Iteration 200, dV=2.87e-05
VFI: Converged after 226 iterations: dV=9.88e-06
    \end{Verbatim}

    Finally, we plot the solution for all levels of labour income. Note that
we need to transpose the result arrays because Matplotlib's
\texttt{plot()} expects input arrays to have the same number of elements
along the first dimension.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{fig}\PY{p}{,} \PY{n}{axes} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{sharex}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{sharey}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot savings in first column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}a}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Savings \PYZdl{}a\PYZca{}}\PY{l+s+s1}{\PYZob{}}\PY{l+s+s1}{\PYZbs{}}\PY{l+s+s1}{prime\PYZcb{}\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Insert legend}
\PY{n}{labels} \PY{o}{=} \PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZdl{}y=}\PY{l+s+si}{\PYZob{}}\PY{n}{y}\PY{l+s+si}{:}\PY{l+s+s1}{.2f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZdl{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{y} \PY{o+ow}{in} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{]}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{n}{labels}\PY{p}{,} \PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{upper left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot consumption in second column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Consumption \PYZdl{}c\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot value function in third column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{vfun}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value func. \PYZdl{}V\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Text(0.5, 0, 'Assets')
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{unit11_files/unit11_51_1.pdf}
    \end{center}
    
    With stochastic labour income, the numerical artifacts produced by grid
search are even more pronounced which speaks against using this method
for this type of problem, if possible.

    \hypertarget{vfi-with-interpolation}{%
\subsubsection{VFI with interpolation}\label{vfi-with-interpolation}}

We can adjust the interpolation algorithm to deal with stochastic labour
income in the same way as we augmented the grid search.

\hypertarget{outline-of-the-algorithm}{%
\subsubsection*{Outline of the algorithm}\label{outline-of-the-algorithm}}

To implement VFI with interpolation, we need to modify the original
algorithm as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset grid \(\Gamma_a = (a_1, \dots, a_{N_a})\).
\item
  Create a discretised labour income process with states
  \(\Gamma_y = (y_1, \dots, y_{N_y})\) and transition matrix \(\Pi_y\).
\item
  Pick an initial guess \(V_0\) for value function defined on
  \(\Gamma_y \times \Gamma_a\).
\item
  In iteration \(n\), perform the following steps:

  For each labour income \(y_i\) at index \(i\),

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Compute the expectation over labour income realisations \(y'\) given
    \(y_i\),
    \[ \widetilde{V}(a') = \mathbb{E}\bigl[V_n(y',a')~|~y_i \bigr]\]
    using the \(i\)-th row of the transition matrix \(\Pi_y\).
  \item
    For each asset level \(a_j\) at grid point \(j\),

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \tightlist
    \item
      Compute the available resources (cash at hand):
      \[x_{ij} = (1+r)a_i + y_i\]
    \item
      Find the maximiser
      \[a^{\star} = \argmax_{a' \in [0, x_{ij}]} \Bigl\{ u\left(x_{ij}-a'\right) + \beta \widetilde{V}(a') \Bigr\}\]
      This step is usually performed using a numerical maximisation (or
      minimisation) routine.
    \item
      The value \(V^{\star}\) is then given by
      \[V^{\star} = u\left(x_{ij}-a^{\star}\right) + \beta \widetilde{V}(a^{\star})\]
    \item
      Store the updated value \(V_{n+1,ij} = V^{\star}\) and the
      associated savings policy function.
    \end{enumerate}
  \end{enumerate}
\item
  Check for convergence: If \(\|V_n-V_{n+1}\| < \epsilon\), for some
  small tolerance \(\epsilon > 0\), exit the algorithm.
\end{enumerate}

    \hypertarget{implementing-vfi-with-interpolation}{%
\subsubsection*{Implementing VFI with
interpolation}\label{implementing-vfi-with-interpolation}}

The following code implements VFI with risky labour income using
interpolation (the code can also be found in
\href{../lectures/unit11/VFI_risk.py}{\texttt{lectures/unit11/VFI\_risk.py}}).

Note that the objective function \texttt{f\_objective()} remains
unchanged from before because we adapted the argument \texttt{f\_vfun}
to interpolate over the pre-computed expected value of
\(\widetilde{V}(a')\) instead of \(V_n(a')\) as in the original
implementation.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{vfi\PYZus{}interp}\PY{p}{(}\PY{n}{par}\PY{p}{,} \PY{n}{tol}\PY{o}{=}\PY{l+m+mf}{1e\PYZhy{}5}\PY{p}{,} \PY{n}{maxiter}\PY{o}{=}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}

    \PY{n}{N\PYZus{}a}\PY{p}{,} \PY{n}{N\PYZus{}y} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{)}
    \PY{n}{shape} \PY{o}{=} \PY{p}{(}\PY{n}{N\PYZus{}y}\PY{p}{,} \PY{n}{N\PYZus{}a}\PY{p}{)}
    \PY{n}{vfun} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{shape}\PY{p}{)}
    \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{empty}\PY{p}{(}\PY{n}{shape}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Optimal savings decision}
    \PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{shape}\PY{p}{)}

    \PY{k}{for} \PY{n}{it} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{maxiter}\PY{p}{)}\PY{p}{:}

        \PY{c+c1}{\PYZsh{} Compute expected continuation value E[V(y\PYZsq{},a\PYZsq{})|y] for each (y,a\PYZsq{})}
        \PY{n}{EV} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{tm\PYZus{}y}\PY{p}{,} \PY{n}{vfun}\PY{p}{)}

        \PY{k}{for} \PY{n}{iy}\PY{p}{,} \PY{n}{y} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{)}\PY{p}{:}

            \PY{c+c1}{\PYZsh{} function to interpolate continuation value}
            \PY{n}{f\PYZus{}vfun} \PY{o}{=} \PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{np}\PY{o}{.}\PY{n}{interp}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{EV}\PY{p}{[}\PY{n}{iy}\PY{p}{]}\PY{p}{)}

            \PY{k}{for} \PY{n}{ia}\PY{p}{,} \PY{n}{a} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} Solve maximization problem at given asset level}
                \PY{c+c1}{\PYZsh{} Cash\PYZhy{}at\PYZhy{}hand at current asset level}
                \PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{a} \PY{o}{+} \PY{n}{y}
                \PY{c+c1}{\PYZsh{} Restrict maximisation to following interval:}
                \PY{n}{bounds} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{0.0}\PY{p}{,} \PY{n}{cah}\PY{p}{)}
                \PY{c+c1}{\PYZsh{} Arguments to be passed to objective function}
                \PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{n}{cah}\PY{p}{,} \PY{n}{par}\PY{p}{,} \PY{n}{f\PYZus{}vfun}\PY{p}{)}
                \PY{c+c1}{\PYZsh{} perform maximisation}
                \PY{n}{res} \PY{o}{=} \PY{n}{minimize\PYZus{}scalar}\PY{p}{(}\PY{n}{f\PYZus{}objective}\PY{p}{,} \PY{n}{bracket}\PY{o}{=}\PY{n}{bounds}\PY{p}{,} \PY{n}{args}\PY{o}{=}\PY{n}{args}\PY{p}{)}

                \PY{c+c1}{\PYZsh{} Minimiser returns NEGATIVE utility, revert that}
                \PY{n}{v\PYZus{}opt} \PY{o}{=} \PY{o}{\PYZhy{}} \PY{n}{res}\PY{o}{.}\PY{n}{fun}
                \PY{n}{sav\PYZus{}opt} \PY{o}{=} \PY{n+nb}{float}\PY{p}{(}\PY{n}{res}\PY{o}{.}\PY{n}{x}\PY{p}{)}

                \PY{n}{vfun\PYZus{}upd}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{v\PYZus{}opt}
                \PY{n}{pfun\PYZus{}a}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{ia}\PY{p}{]} \PY{o}{=} \PY{n}{sav\PYZus{}opt}

        \PY{n}{diff} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{vfun} \PY{o}{\PYZhy{}} \PY{n}{vfun\PYZus{}upd}\PY{p}{)}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} switch references to value functions for next iteration}
        \PY{n}{vfun}\PY{p}{,} \PY{n}{vfun\PYZus{}upd} \PY{o}{=} \PY{n}{vfun\PYZus{}upd}\PY{p}{,} \PY{n}{vfun}

        \PY{k}{if} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{n}{tol}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Converged after }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations: dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
            \PY{k}{break}
        \PY{k}{elif} \PY{n}{it} \PY{o}{==} \PY{l+m+mi}{1} \PY{o+ow}{or} \PY{n}{it} \PY{o}{\PYZpc{}} \PY{l+m+mi}{50} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{VFI: Iteration }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{3d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Did not converge in }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations}\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}

    \PY{k}{return} \PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    The following code is used to perform the VFI. Note that once as in the
deterministic setting, the savings policy function returns savings
\emph{levels}, even though now all return values are 2-dimensional
arrays.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{vfun}\PY{p}{,} \PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{vfi\PYZus{}interp}\PY{p}{(}\PY{n}{par}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Recover consumption policy function from budget constraint}
\PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{[}\PY{p}{:}\PY{p}{,} \PY{k+kc}{None}\PY{p}{]}
\PY{n}{pfun\PYZus{}c} \PY{o}{=} \PY{n}{cah} \PY{o}{\PYZhy{}} \PY{n}{pfun\PYZus{}a}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/richard/.conda/envs/python-intro-PGR/lib/python3.10/site-
packages/scipy/optimize/\_optimize.py:2417: RuntimeWarning: invalid value
encountered in scalar multiply
  tmp2 = (x - v) * (fx - fw)
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
VFI: Iteration   0, dV=2.52e+00
VFI: Iteration   1, dV=1.38e+00
VFI: Iteration  50, dV=2.95e-02
VFI: Iteration 100, dV=1.95e-03
VFI: Iteration 150, dV=2.16e-04
VFI: Iteration 200, dV=2.73e-05
VFI: Converged after 225 iterations: dV=9.80e-06
    \end{Verbatim}

    We use the same code as above to visualise the results:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{fig}\PY{p}{,} \PY{n}{axes} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{sharex}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{sharey}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot savings in first column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}a}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Savings \PYZdl{}a\PYZca{}}\PY{l+s+s1}{\PYZob{}}\PY{l+s+s1}{\PYZbs{}}\PY{l+s+s1}{prime\PYZcb{}\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Insert legend}
\PY{n}{labels} \PY{o}{=} \PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZdl{}y=}\PY{l+s+si}{\PYZob{}}\PY{n}{y}\PY{l+s+si}{:}\PY{l+s+s1}{.2f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZdl{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{y} \PY{o+ow}{in} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{]}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{n}{labels}\PY{p}{,} \PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{upper left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot consumption in second column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Consumption \PYZdl{}c\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot value function in third column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{vfun}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value func. \PYZdl{}V\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Text(0.5, 0, 'Assets')
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{unit11_files/unit11_59_1.pdf}
    \end{center}
    
    The policy functions are much smoother compared to those produced by
grid search. However, as you can see there is another artifact of our
numerical implementation that did not stand out as much earlier: the
consumption policy for the highest labour state is suspiciously
upward-sloping towards the end! This is a consequence of not permitting
extrapolation of the continuation value, and hence any savings that
would take the household beyond the grid upper bound are wasted. It is
therefore optimal to consume all such ``excess'' savings, which gives
rise to the increase in consumption at the right end of the asset grid.
We could address this problem by allowing extrapolation, but linear
extrapolation of value functions is undesirable for other reasons.


\hypertarget{egm-with-stochastic-labour-income}{%
\subsection{EGM with stochastic labour
income}\label{egm-with-stochastic-labour-income}}

While value function iteration is a robust and long-established method
to solve dynamic problems, it tends to be slow when combined with
interpolation, while it produces numerical artifacts when combined with
grid search. The endogenous grid-point method (EGM) due to Carroll
(2005) addresses both the issue of speed and at the same time produces
smooth and accurate solutions.

To fix ideas, let's revisit the stochastic labour income we studied
above: \[
\begin{aligned}
V(y,a) = &\max_{c,\,a'}~\Bigl\{ u(c)
    + \beta \mathbb{E}\bigl[\left.V(y',a')~\right|~ y\bigr] \Bigr\} \\
    \text{s.t.} \quad &c + a' = (1+r)a  + y \\
    & c \geq 0,\; a' \geq 0
\end{aligned}
\] The optimality conditions for this problem are the standard Euler
equation combined with the budget constraint: \[
\begin{aligned}
c^{-\gamma} &= \beta (1+r) \mathbb{E}\left[\left.(c')^{-\gamma}\right| y\right] \\
c + a' &= (1+r)a + y
\end{aligned}
\] So far, we haven't used the Euler equation at all, but it can be
leveraged to invert the problem and speed up the solution. Suppose that
instead of trying to determine the optimal savings level \(a'\) for an
exogenously given beginning-of-period asset level \(a\), we ask the
following: if we exogenously impose that the household optimally saves
\(a'\), what is the beginning-of-period asset level \(a\) that
rationalizes this savings choice given the household's optimality
conditions?

    To answer this question, assume we have a guess for the consumption
policy function \(C(y,a)\); for example, we could initially impose that
the household chooses to consume everything, \ie \(C(y,a) = a\). For a
given \(a'\), from the Euler equation we know that \[
(c^*)^{-\gamma} = \beta (1+r) \mathbb{E}\left[ \left.C(y',a')^{-\gamma}~\right|~y \right]
\] where we use the notation \(c^*\) to indicate that this consumption
level is a function of the exogenously imposed \(a'\). Consequently,
optimal consumption today must be given by \[
c^* = \Bigl( \beta (1+r) \mathbb{E}\left[ \left.C(y',a')^{-\gamma}~\right|~y \right] \Bigr)^{-\frac{1}{\gamma}}
\] With \(c^*\) and \(a'\) in hand, the only unknown in the budget
constraint are the beginning-of-period assets \(a^*\) which we again
denote using \(*\) to stress that it is a function of the exogenous
\(a'\): \[
a^* = \frac{c^* + a' - y}{1+r}
\] Note that the beginning-of-period assets \(a^*\) thus arise
\emph{endogenously} as a function of the exogenously-imposed optimal
savings \(a'\), hence the name \emph{endogenous} grid-point method.

To summarize, every point on the exogenous savings
\(\Gamma_{a'} = \{a'_1, a'_2, \dots, a'_{N_{a'}}\}\) gives rise to an
endogenous tuple of values \((c^*, a^*)\). After applying this procedure
to all \(N_{a'}\) exogenous savings levels, we have the collection of
values \((c_i^*)_{i=1}^{N_{a'}}\) and \((a_i^*)_{i=1}^{N_{a'}}\). We are
usually not interested in characterising the solution to the household
problem as a function of the endogenous grid of
\(\{a^*_1,a^*_2,\dots\}\), so the final step is to use these points to
interpolate the consumption policy function back onto our standard
beginning-of-period asset grid
\(\Gamma_a = \{a_1, a_2, \dots, a_{N_a}\}\). This yields an updated
consumption policy function \(C(y,a)\) mapping \(a\) into \(c\) which we
can use in the next iteration.

    \hypertarget{outline-of-the-algorithm}{%
\subsubsection*{Outline of the algorithm}\label{outline-of-the-algorithm}}

To solve the household problem with stochastic labour income with EGM,
we proceed as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create an asset grid \(\Gamma_a = (a_1, \dots, a_{N_a})\) and
  optionally and exogenous savings grid
  \(\Gamma_{a'} = (a_1', \dots, a'_{N_{a'}})\). For simplicity we use
  the same grid for both purposes.
\item
  Create a discretised labour income process with states
  \(\Gamma_y = (y_1, \dots, y_{N_y})\) and transition matrix \(\Pi_y\).
\item
  Pick an initial guess \(C_0(y,a)\) for the consumption policy function
  defined on \(\Gamma_y \times \Gamma_a\). One possibility is to assume
  that \(C_0(y,a) = a\).
\item
  In iteration \(n\), perform the following steps:

  For each labour income \(y_i\) at index \(i\),

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Compute the vector of \emph{expected marginal utilities} for all
    points \(a'_j\) on the exogenous savings grid with typical element
    \[m_{ij} \equiv \mathbb{E}\left[\left.C_n\left(y',a'_j\right)^{-\gamma}~\right|~y_i \right]\]
  \item
    Invert the Euler equation to get a vector of today's consumption
    levels, \[
    c^*_{ij} = \bigl[ \beta (1+r) m_{ij} \bigr]^{-\frac{1}{\gamma}}
    \]
  \item
    Use the budget constraint to find the vector of required
    beginning-of-period asset levels \[
    a_{ij}^* = \frac{c_{ij}^* + a'_j - y_i}{1+r}
    \]
  \item
    Use the collection of values \((a_{ij})_{j=1}^{N_{a'}}\) and
    \((c_{ij})_{j=1}^{N_{a'}}\) to interpolate optimal consumption onto
    the beginning-of-period asset grid \(\Gamma_a\). This yields an
    updated guess for \(C_{n+1}(y_i,a)\).
  \item
    Finally, note that the Euler equation only holds for \emph{interior}
    solutions but does not hold when the household is borrowing
    constraint. The endogenous grid point \(a_{i1}^*\) associated with
    the first savings grid-point \(a'_{1} = 0\) exactly identifies the
    beginning-of-period asset level at which the household is no longer
    borrowing constraint. For all asset levels below this point, we know
    that the household will choose not to save, so we set
    \[C_{n+1}(y_i,a) = (1+r)a + y_i \quad \forall a < a_{i1}^*\]
  \end{enumerate}
\item
  Check for convergence: If \(\|C_n-C_{n+1}\| < \epsilon\), for some
  small tolerance \(\epsilon > 0\), exit the algorithm.
\end{enumerate}

    \hypertarget{implementing-egm-with-stochastic-labour-income}{%
\subsubsection*{Implementing EGM with stochastic labour
income}\label{implementing-egm-with-stochastic-labour-income}}

The \texttt{lectures/unit11} folder contains two EGM implementations,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{../lectures/unit11/EGM.py}{\texttt{lectures/unit11/EGM.py}}:
  implements infinite-horizon EGM for the problem with deterministic
  labour income;
\item
  \href{../lectures/unit11/EGM_risk.py}{\texttt{lectures/unit11/EGM\_risk.py}}:
  implements infinite-horizon EGM for the problem with stochastic labour
  income.
\end{enumerate}

Setting up the problem is identical to the case of VFI, see
\href{../lectures/unit11/main.py}{\texttt{lectures/unit11/main.py}} for
the problem with deterministic labour and
\href{../lectures/unit11/main_risk.py}{\texttt{lectures/unit11/main\_risk.py}}
for the stochastic version. For completeness, the implementation is
shown below. Note that here we use SciPy's interpolation routine
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html}{\texttt{interp1d()}}
since it supports extrapolation, unlike its NumPy counterpart
\href{https://numpy.org/doc/stable/reference/generated/numpy.interp.html}{\texttt{np.interp()}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{interpolate} \PY{k+kn}{import} \PY{n}{interp1d} 

\PY{k}{def} \PY{n+nf}{egm}\PY{p}{(}\PY{n}{par}\PY{p}{,} \PY{n}{tol}\PY{o}{=}\PY{l+m+mf}{1.0e\PYZhy{}8}\PY{p}{,} \PY{n}{maxiter}\PY{o}{=}\PY{l+m+mi}{10000}\PY{p}{)}\PY{p}{:}

    \PY{n}{N\PYZus{}a}\PY{p}{,} \PY{n}{N\PYZus{}y} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{)}
    \PY{n}{shape} \PY{o}{=} \PY{p}{(}\PY{n}{N\PYZus{}y}\PY{p}{,} \PY{n}{N\PYZus{}a}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Cash\PYZhy{}at\PYZhy{}hand at every asset/savings level}
    \PY{n}{cah} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{[}\PY{k+kc}{None}\PY{p}{]} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{[}\PY{p}{:}\PY{p}{,} \PY{k+kc}{None}\PY{p}{]}

    \PY{c+c1}{\PYZsh{} Initial guess for consumption policy function}
    \PY{n}{pfun\PYZus{}c} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{cah}\PY{p}{)}
    \PY{n}{pfun\PYZus{}c\PYZus{}upd} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{shape}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Extract parameters from par object}
    \PY{n}{beta}\PY{p}{,} \PY{n}{gamma}\PY{p}{,} \PY{n}{r} \PY{o}{=} \PY{n}{par}\PY{o}{.}\PY{n}{beta}\PY{p}{,} \PY{n}{par}\PY{o}{.}\PY{n}{gamma}\PY{p}{,} \PY{n}{par}\PY{o}{.}\PY{n}{r}

    \PY{k}{for} \PY{n}{it} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{maxiter}\PY{p}{)}\PY{p}{:}

        \PY{c+c1}{\PYZsh{} Iterate over all labour income states}
        \PY{k}{for} \PY{n}{iy}\PY{p}{,} \PY{n}{y} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{)}\PY{p}{:}

            \PY{c+c1}{\PYZsh{} Expected marginal utility tomorrow}
            \PY{n}{mu} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{tm\PYZus{}y}\PY{p}{[}\PY{n}{iy}\PY{p}{]}\PY{p}{,} \PY{n}{pfun\PYZus{}c}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{gamma}\PY{p}{)}\PY{p}{)}
            \PY{c+c1}{\PYZsh{} Compute right\PYZhy{}hand side of Euler equation (EE)}
            \PY{n}{ee\PYZus{}rhs} \PY{o}{=} \PY{n}{beta} \PY{o}{*} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{r}\PY{p}{)} \PY{o}{*} \PY{n}{mu}

            \PY{c+c1}{\PYZsh{} Invert EE to get consumption as a function of savings today}
            \PY{n}{cons\PYZus{}sav} \PY{o}{=} \PY{n}{ee\PYZus{}rhs}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.0}\PY{o}{/}\PY{n}{gamma}\PY{p}{)}

            \PY{c+c1}{\PYZsh{} Use budget constraint to get beginning\PYZhy{}of\PYZhy{}period assets}
            \PY{n}{assets\PYZus{}sav} \PY{o}{=} \PY{p}{(}\PY{n}{cons\PYZus{}sav} \PY{o}{+} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{\PYZhy{}} \PY{n}{y}\PY{p}{)} \PY{o}{/} \PY{p}{(}\PY{l+m+mf}{1.0} \PY{o}{+} \PY{n}{r}\PY{p}{)}

            \PY{c+c1}{\PYZsh{} Interpolate back onto exogenous savings grid}
            \PY{n}{f\PYZus{}cons} \PY{o}{=} \PY{n}{interp1d}\PY{p}{(}
                \PY{n}{assets\PYZus{}sav}\PY{p}{,} \PY{n}{cons\PYZus{}sav}\PY{p}{,} 
                \PY{n}{copy}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{assume\PYZus{}sorted}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,}
                \PY{n}{bounds\PYZus{}error}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{fill\PYZus{}value}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{extrapolate}\PY{l+s+s1}{\PYZsq{}}
            \PY{p}{)}
            \PY{n}{pfun\PYZus{}c\PYZus{}upd}\PY{p}{[}\PY{n}{iy}\PY{p}{]} \PY{o}{=} \PY{n}{f\PYZus{}cons}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{)}

            \PY{c+c1}{\PYZsh{} Fix consumption in region where HH does not save}
            \PY{n}{amin} \PY{o}{=} \PY{n}{assets\PYZus{}sav}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
            \PY{n}{idx} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{amin}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
            \PY{c+c1}{\PYZsh{} HH consumes entire cash\PYZhy{}at\PYZhy{}hand}
            \PY{n}{pfun\PYZus{}c\PYZus{}upd}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{cah}\PY{p}{[}\PY{n}{iy}\PY{p}{,} \PY{n}{idx}\PY{p}{]}

        \PY{c+c1}{\PYZsh{} Make sure that consumption policy satisfies constraints}
        \PY{k}{assert} \PY{n}{np}\PY{o}{.}\PY{n}{all}\PY{p}{(}\PY{n}{pfun\PYZus{}c\PYZus{}upd} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mf}{0.0}\PY{p}{)} \PY{o+ow}{and} \PY{n}{np}\PY{o}{.}\PY{n}{all}\PY{p}{(}\PY{n}{pfun\PYZus{}c\PYZus{}upd} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{cah}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} Compute max. absolute difference to policy function from previous}
        \PY{c+c1}{\PYZsh{} iteration.}
        \PY{n}{diff} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{n}{pfun\PYZus{}c} \PY{o}{\PYZhy{}} \PY{n}{pfun\PYZus{}c\PYZus{}upd}\PY{p}{)}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} switch references to policy functions for next iteration}
        \PY{n}{pfun\PYZus{}c}\PY{p}{,} \PY{n}{pfun\PYZus{}c\PYZus{}upd} \PY{o}{=} \PY{n}{pfun\PYZus{}c\PYZus{}upd}\PY{p}{,} \PY{n}{pfun\PYZus{}c}

        \PY{k}{if} \PY{n}{diff} \PY{o}{\PYZlt{}} \PY{n}{tol}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Convergence achieved, exit loop}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGM: Converged after }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations: d(c)=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
            \PY{k}{break}
        \PY{k}{elif} \PY{n}{it} \PY{o}{==} \PY{l+m+mi}{1} \PY{o+ow}{or} \PY{n}{it} \PY{o}{\PYZpc{}} \PY{l+m+mi}{50} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{EGM: Iteration }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{4d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, dV=}\PY{l+s+si}{\PYZob{}}\PY{n}{diff}\PY{l+s+si}{:}\PY{l+s+s1}{4.2e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{msg} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Did not converge in }\PY{l+s+si}{\PYZob{}}\PY{n}{it}\PY{l+s+si}{:}\PY{l+s+s1}{d}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ iterations}\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{msg}\PY{p}{)}

    \PY{n}{pfun\PYZus{}a} \PY{o}{=} \PY{n}{cah} \PY{o}{\PYZhy{}} \PY{n}{pfun\PYZus{}c}

    \PY{k}{return} \PY{n}{pfun\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c}
\end{Verbatim}
\end{tcolorbox}

    The following code runs and plots the results. It assumes that the
parameters have been initialised as shown in the previous sections. Note
that the EGM method does not return the value function since it is not
needed for the algorithm. Once the policy functions have been computed,
it is however possible to construction the value function from these by
iteration (without having to perform maximisation since we already know
the optimal choices).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Run EGM, store savings and consumption policy functions.}
\PY{n}{pfun\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c} \PY{o}{=} \PY{n}{egm}\PY{p}{(}\PY{n}{par}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
EGM: Iteration    0, dV=5.13e+00
EGM: Iteration    1, dV=1.73e+00
EGM: Iteration   50, dV=4.54e-03
EGM: Iteration  100, dV=3.29e-04
EGM: Iteration  150, dV=2.47e-05
EGM: Iteration  200, dV=1.88e-06
EGM: Iteration  250, dV=1.44e-07
EGM: Iteration  300, dV=1.10e-08
EGM: Converged after 302 iterations: d(c)=9.95e-09
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Visualise the EGM solution}
\PY{n}{fig}\PY{p}{,} \PY{n}{axes} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{sharex}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{sharey}\PY{o}{=}\PY{k+kc}{False}\PY{p}{,} \PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mf}{6.5}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot savings in first column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}a}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Savings \PYZdl{}a\PYZca{}}\PY{l+s+s1}{\PYZob{}}\PY{l+s+s1}{\PYZbs{}}\PY{l+s+s1}{prime\PYZcb{}\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Insert legend}
\PY{n}{labels} \PY{o}{=} \PY{p}{[}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZdl{}y=}\PY{l+s+si}{\PYZob{}}\PY{n}{y}\PY{l+s+si}{:}\PY{l+s+s1}{.2f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZdl{}}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{y} \PY{o+ow}{in} \PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}y}\PY{p}{]}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{n}{labels}\PY{p}{,} \PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{upper left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Plot consumption in second column}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{par}\PY{o}{.}\PY{n}{grid\PYZus{}a}\PY{p}{,} \PY{n}{pfun\PYZus{}c}\PY{o}{.}\PY{n}{T}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+sa}{r}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Consumption \PYZdl{}c\PYZdl{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{axes}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Assets}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
Text(0.5, 0, 'Assets')
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{unit11_files/unit11_68_1.pdf}
    \end{center}
    
    We close this section with a comment on the relative run time of the
methods we have studied above to solve the problem with stochastic
labour income. The following table shows the relative run times of each
solution method, with the run time for VFI with grid search normalised
to one. The problem is solved on 50 asset grid points and risky labour
income is discretised to three grid points.

\begin{longtable}[]{@{}ll@{}}
\toprule
Method & Relative run time\tabularnewline
\midrule
\endhead
VFI + grid search & 1.00\tabularnewline
VFI + linear interp. & 22.01\tabularnewline
EGM & 0.21\tabularnewline
\bottomrule
\end{longtable}

As you can see, EGM is not only more accurate but also 5 times faster
than VFI with grid search, and 100 times faster than VFI with linear
interpolation which on top yields worse results.


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
