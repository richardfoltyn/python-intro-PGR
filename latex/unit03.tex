\documentclass{scrartcl}

    \usepackage{jupyterlatex}
    \usepackage[breakable]{tcolorbox}
    

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro

    \usepackage{iftex}
    \ifPDFTeX
        \usepackage[T1]{fontenc}
        \IfFileExists{alphabeta.sty}{
              \usepackage{alphabeta}
          }{
              \usepackage[mathletters]{ucs}
              \usepackage[utf8]{inputenc}
          }
    \else
        \usepackage{fontspec}
        \usepackage{unicode-math}
    \fi

    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, \etc)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage{array}     % table support for pandoc >= 2.11.3
    \usepackage{calc}      % table minipage width calculation for pandoc >= 2.11.1
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}

    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}


    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \newcommand*{\unitcounter}{3}
    \addtocounter{section}{\unitcounter}
    \addtocounter{section}{-1}
    \newcommand*{\mytitle}{Unit \unitcounter: Reusing code -- Functions, modules and packages}

    \input{overrides-post}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb.
    \makeatletter
        \newbox\Wrappedcontinuationbox
        \newbox\Wrappedvisiblespacebox
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}}
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}}
        \newcommand*\Wrappedcontinuationindent {3ex }
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox}
        % Take advantage of the already applied Pygments mark-up to insert
        % potential linebreaks for TeX processing.
        %        {, <, #, %, $, ' and ": go to next line.
        %        _, }, ^, &, >, - and ~: stay at end of broken line.
        % Use of \textquotesingle for straight quote.
        \newcommand*\Wrappedbreaksatspecials {%
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}%
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}%
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}%
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}%
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}%
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}%
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}%
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}%
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}%
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}%
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}%
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}%
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}%
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}%
        }
        % Some characters . , ; ? ! / are not pygmentized.
        % This macro makes them "active" and they will insert potential linebreaks
        \newcommand*\Wrappedbreaksatpunct {%
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}%
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}%
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}%
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}%
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}%
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}%
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}%
            \catcode`\.\active
            \catcode`\,\active
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active
            \lccode`\~`\~
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%

        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active
        \OriginalVerbatim[#1,fontsize=\small,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{FCFCFC}

    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    \tableofcontents
    
    

    
    \hypertarget{reusing-code-functions-modules-and-packages}{%
\section{Reusing code: Functions, modules and
packages}\label{reusing-code-functions-modules-and-packages}}

In this unit, we learn how to build reusable code with functions. We
will also briefly discuss modules and packages.

\hypertarget{functions}{%
\subsection{Functions}\label{functions}}

Functions are used to implement code that performs a narrowly defined
task. We use functions for two reasons:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A function can be called repeatedly without having to write code again
  and again.
\item
  Even if a function is not called frequently, functions allow us to
  write code that is ``shielded'' from other code we write and is called
  via a clean interface. This helps to write more robust and error-free
  code.
\end{enumerate}

Functions are defined using the \texttt{def} keyword, and the function
body needs to be an indented block:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func called}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} invoke func without arguments}
\PY{n}{func}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func called
    \end{Verbatim}

    \hypertarget{arguments}{%
\subsubsection{Arguments}\label{arguments}}

Functions can have an arbitrary number of positional arguments (also
called parameters).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Define func to accept argument x}
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func called with argument }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} call function with various arguments.}
\PY{n}{func}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\PY{n}{func}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{foo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func called with argument 1
func called with argument foo
    \end{Verbatim}

    \hypertarget{return-values}{%
\subsubsection{Return values}\label{return-values}}

Functions can also return values to their caller using the
\texttt{return} statement.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{x} \PY{o}{*} \PY{l+m+mf}{2.0}

\PY{n}{result} \PY{o}{=} \PY{n}{func}\PY{p}{(}\PY{l+m+mf}{1.0}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{result}\PY{p}{)}       \PY{c+c1}{\PYZsh{} prints 2.0}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
2.0
    \end{Verbatim}

    A \texttt{return} statement without any argument immediately exits the
functions. The default return value is the special type \texttt{None}.

A function can return multiple values which are then automatically
collected into a tuple:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}

\PY{n}{values} \PY{o}{=} \PY{n}{func}\PY{p}{(}\PY{p}{)}         \PY{c+c1}{\PYZsh{} call func(), get tuple of values}
\PY{n+nb}{type}\PY{p}{(}\PY{n}{values}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
tuple
\end{Verbatim}
\end{tcolorbox}
        
    Python supports ``unpacking'' of tuples, lists, \etc We can use this to
directly assign names to multiple return values:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}

\PY{n}{value1}\PY{p}{,} \PY{n}{value2}\PY{p}{,} \PY{n}{value3} \PY{o}{=} \PY{n}{func}\PY{p}{(}\PY{p}{)}     \PY{c+c1}{\PYZsh{} call func(), unpack return values}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Value 1: }\PY{l+s+si}{\PYZob{}}\PY{n}{value1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, Value 2: }\PY{l+s+si}{\PYZob{}}\PY{n}{value2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, Value 3: }\PY{l+s+si}{\PYZob{}}\PY{n}{value3}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Value 1: a, Value 2: b, Value 3: c
    \end{Verbatim}

    \hypertarget{accessing-data-from-the-outer-scope}{%
\subsubsection{Accessing data from the outer
scope}\label{accessing-data-from-the-outer-scope}}

A function need not have arguments or a return value, but that limits
its usefulness somewhat. However, a function can access outside data
which is defined in the so-called outer scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{l+m+mf}{1.0}
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Read x from outer scope}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func accessing x from outer scope: x = }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} prints value of x from within func()}
\PY{n}{func}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func accessing x from outer scope: x = 1.0
    \end{Verbatim}

    We can write functions without any arguments that only operate on
outside data. However, this is terrible programming practice and should
be avoided in most cases.

Because functions can operate on external data, they are not analogous
to mathematical functions. If we write \(f(x)\), we usually mean that
\(f\) is a function of \(x\) only (and possibly some constant
parameters). By definition we must have

\[x_1 = x_2 \Longrightarrow f(x_1) = f(x_2),\]

\ie a function always returns the same value when called with the same
parameters. However, this is not the case in Python or most other
programming languages:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{a} \PY{o}{=} \PY{l+m+mf}{1.0}
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{a}\PY{o}{*}\PY{n}{x}

\PY{n}{x} \PY{o}{=} \PY{l+m+mf}{1.0}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{)}      \PY{c+c1}{\PYZsh{} prints 1.0}

\PY{n}{a} \PY{o}{=} \PY{l+m+mf}{2.0}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{)}      \PY{c+c1}{\PYZsh{} x unchanged, but prints 2.0}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
1.0
2.0
    \end{Verbatim}

    \hypertarget{more-on-arguments}{%
\subsubsection{More on arguments}\label{more-on-arguments}}

\textbf{Default arguments}

Python offers an extremely convenient way to specify default values for
arguments, so these need not be passed when the function is called:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} define function with a default value for argument alpha}
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{alpha}\PY{o}{=}\PY{l+m+mf}{1.0}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{x} \PY{o}{*} \PY{n}{alpha}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{func}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{)}\PY{p}{)}        \PY{c+c1}{\PYZsh{} uses default value for alpha}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{func}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{,} \PY{l+m+mf}{1.0}\PY{p}{)}\PY{p}{)}   \PY{c+c1}{\PYZsh{} explicitly specified optional argument}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{func}\PY{p}{(}\PY{l+m+mf}{2.0}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{)}\PY{p}{)}   \PY{c+c1}{\PYZsh{} use some other value for alpha}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
2.0
2.0
6.0
    \end{Verbatim}

    \textbf{Keyword (or named) arguments}

Arguments don't need to be provided in the same order as specified in
the function signature. We can use argument names to explicitly assign
values to the corresponding argument.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{arg1}\PY{p}{,} \PY{n}{arg2}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{arg1: }\PY{l+s+si}{\PYZob{}}\PY{n}{arg1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{, arg2: }\PY{l+s+si}{\PYZob{}}\PY{n}{arg2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{n}{func}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}              \PY{c+c1}{\PYZsh{} Call using purely positional arguments}
\PY{n}{func}\PY{p}{(}\PY{n}{arg1}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{arg2}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}    \PY{c+c1}{\PYZsh{} Use argument names to explicitly assign values}
\PY{n}{func}\PY{p}{(}\PY{n}{arg2}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{arg1}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}    \PY{c+c1}{\PYZsh{} With keyword arguments, the order does not matter!}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
arg1: 1, arg2: 2
arg1: 1, arg2: 2
arg1: 1, arg2: 2
    \end{Verbatim}

    \textbf{Arbitrary number of optional arguments}

Python supports functions which accept an arbitrary number of positional
and keyword arguments. This is accomplished via two special tokens:

\begin{itemize}
\tightlist
\item
  \texttt{*args}: collects any number of ``excess'' \emph{positional
  arguments} and packs them into a tuple.
\item
  \texttt{**kwargs}: collects any number of ``excess'' \emph{keyword
  arguments} and packs them into a dictionary. Needs to be placed at the
  end of the argument list!
\end{itemize}

\vspace{1em}\emph{Examples:}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Define function with mandatory, optional, optional positional}
\PY{c+c1}{\PYZsh{} and optional keyword arguments}

\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{opt}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{default}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{o}{*}\PY{n}{args}\PY{p}{,} \PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Required argument x: }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Optional argument opt: }\PY{l+s+si}{\PYZob{}}\PY{n}{opt}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{if} \PY{n}{args}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} if the tuple \PYZsq{}args\PYZsq{} is non\PYZhy{}empty, print its contents}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Optional positional arguments:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{for} \PY{n}{arg} \PY{o+ow}{in} \PY{n}{args}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{  }\PY{l+s+si}{\PYZob{}}\PY{n}{arg}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{if} \PY{n}{kwargs}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} if the dictionary \PYZsq{}kwargs\PYZsq{} is non\PYZhy{}empty, print its contents}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Optional keyword arguments:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n}{kwargs}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{  }\PY{l+s+si}{\PYZob{}}\PY{n}{key}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{: }\PY{l+s+si}{\PYZob{}}\PY{n}{value}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Call only with required argument}
\PY{n}{func}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Required argument x: 0
Optional argument opt: default
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Call with required and optional arguments}
\PY{n}{func}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{optional}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Required argument x: 0
Optional argument opt: optional
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Call with required and optional arguments, and}
\PY{c+c1}{\PYZsh{} optional positional arguments}
\PY{n}{func}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{optional}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Required argument x: 0
Optional argument opt: optional
Optional positional arguments:
  1
  2
  3
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Call with required and optional arguments, and}
\PY{c+c1}{\PYZsh{} optional positional and keyword arguments}
\PY{n}{func}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{optional}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{arg1}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{value1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{arg2}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{value2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Required argument x: 0
Optional argument opt: optional
Optional positional arguments:
  1
  2
  3
Optional keyword arguments:
  arg1: value1
  arg2: value2
    \end{Verbatim}

    We don't even need to specify arguments in the order they are defined in
the function, except for optional positional arguments, since these have
no argument names. We can just use the \texttt{name=value} syntax:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} call func() with interchanged argument order}
\PY{n}{func}\PY{p}{(}\PY{n}{opt}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{optional value}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{x}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Required argument x: 1
Optional argument opt: optional value
    \end{Verbatim}

    Note, however, that in a function call any positional arguments must
come first and those passed as \texttt{name=value} pairs last:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{1}

\PY{c+c1}{\PYZsh{} this will not work, cannot specify positional arguments last}
\PY{n}{func}\PY{p}{(}\PY{n}{opt}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{optional value}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{x}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-cyan}{  Cell }\textcolor{ansi-green}{In[16], line 4}
\textcolor{ansi-red}{    func(opt='optional value', x)}
                                \^{}
\textcolor{ansi-red}{SyntaxError}\textcolor{ansi-red}{:} positional argument follows keyword argument

    \end{Verbatim}

    The same applies for optional arguments passed in via \texttt{*args} and
\texttt{**kwargs}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} fails because arguments collected in *args must}
\PY{c+c1}{\PYZsh{} be specified before arguments collected in **kwargs!}
\PY{n}{func}\PY{p}{(}\PY{l+m+mf}{1.0}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{opt}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{arg1}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{value1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{arg2}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{value2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
     
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-cyan}{  Cell }\textcolor{ansi-green}{In[17], line 3}
\textcolor{ansi-red}{    func(1.0, 'opt', arg1='value1', arg2='value2', 1, 2, 3)}
                                                          \^{}
\textcolor{ansi-red}{SyntaxError}\textcolor{ansi-red}{:} positional argument follows keyword argument

    \end{Verbatim}

    \hypertarget{modifying-data-in-the-outer-scope}{%
\subsubsection{Modifying data in the outer
scope}\label{modifying-data-in-the-outer-scope}}

So far, we covered read-only access to data defined outside of a
function and relied on return values to pass results back to the caller.
However, it is possible to directly \emph{modify} data in the outer
scope, even though this should usually be avoided:

\begin{itemize}
\tightlist
\item
  Using arguments and return values clearly defines a function's
  interface, there are no unpleasant surprises.
\item
  Conversely, if a function starts modifying values in the caller's
  environment, there is no way to be sure what the function is changing
  in the outer scope other than by examining its source code.
\end{itemize}

Consider first the following attempt to modify a value defined outside
of the function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{outer scope}\PY{l+s+s1}{\PYZsq{}}

\PY{c+c1}{\PYZsh{} Create function, assign value to var}
\PY{k}{def} \PY{n+nf}{modify\PYZus{}var}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inner scope}\PY{l+s+s1}{\PYZsq{}}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}
\PY{n}{modify\PYZus{}var}\PY{p}{(}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
outer scope
outer scope
    \end{Verbatim}

    This code prints
\texttt{\textquotesingle{}outer\ scope\textquotesingle{}} twice. What
happened? Without any further instructions, the assignment inside the
function creates a \emph{local} variable \texttt{var} that is completely
disconnected from \texttt{var} in the outer scope!

We need to use the \texttt{global} statement to tell Python to instead
assign to a variable in the global (outer) scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{var}  \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{outer scope}\PY{l+s+s1}{\PYZsq{}}

\PY{k}{def} \PY{n+nf}{modify\PYZus{}var}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{var} 
    \PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inner scope}\PY{l+s+s1}{\PYZsq{}}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}
\PY{n}{modify\PYZus{}var}\PY{p}{(}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
outer scope
inner scope
    \end{Verbatim}

    The second output now reads
\texttt{\textquotesingle{}inner\ scope\textquotesingle{}}.

Note that \texttt{global} in Python actually means global to a module,
\ie a symbol that is defined at the top level within a module (we
discuss modules below). There are no truly global variables in Python
unlike in languages such as C.

The requirement that the name in the \texttt{global} statement refers to
a global variable has subtle implications. Consider the following
example of two \emph{nested} functions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{outer}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{outer function}\PY{l+s+s1}{\PYZsq{}}
    
    \PY{k}{def} \PY{n+nf}{inner}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Bind var to global name var}
        \PY{k}{global} \PY{n}{var}
        \PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inner function}\PY{l+s+s1}{\PYZsq{}}

    \PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}
    \PY{n}{inner}\PY{p}{(}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}

\PY{n}{outer}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
outer function
outer function
    \end{Verbatim}

    Surprisingly, the code above prints
\texttt{\textquotesingle{}outer\ function\textquotesingle{}} twice. The
reason is that \texttt{var} defined in \texttt{outer()} is \emph{not} a
global variable as it was not defined at the top level within a module.
Instead, it is a \emph{local} variable in \texttt{outer()}.

For such scenarios, Python has the \texttt{nonlocal} statement which
works similarly to \texttt{global} except that it operates on a name in
the immediate outer scope, irrespective of whether this outer scope is
another function or the module itself.

We can use \texttt{nonlocal} to get the desired behaviour:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{outer}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} var is in outer\PYZsq{}s local scope}
    \PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{outer function}\PY{l+s+s1}{\PYZsq{}}
    
    \PY{k}{def} \PY{n+nf}{inner}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} bind var to name in immediate outer scope,}
        \PY{c+c1}{\PYZsh{} which is the local scope of outer()}
        \PY{k}{nonlocal} \PY{n}{var}
        \PY{n}{var} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inner function}\PY{l+s+s1}{\PYZsq{}}

    \PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}
    \PY{n}{inner}\PY{p}{(}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}

\PY{n}{outer}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
outer function
inner function
    \end{Verbatim}

    \hypertarget{pass-by-value-or-pass-by-reference}{%
\subsubsection{Pass by value or pass by
reference?}\label{pass-by-value-or-pass-by-reference}}

Can functions modify their arguments? This questions usually comes down
to whether a function call uses \emph{pass by value} or \emph{pass by
reference}:

\begin{itemize}
\tightlist
\item
  \emph{pass by value} means that a copy of every argument is created
  before it is passed into the function. A function therefore cannot
  modify a value in the caller's environment.
\item
  \emph{pass by reference} means that only a reference to a value is
  passed to the function, so the function can directly modify values at
  the call site.
\end{itemize}

This programming model is used in languages such as C (pass by value) or
Fortran (pass by reference), but not in Python. Sloppily speaking, we
can say that in Python a reference (``variable name'') is passed by
value. This means assigning a different value to an argument (``the
reference'') within a function has no effect outside of the function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} x now points to something else}
    \PY{n}{x} \PY{o}{=} \PY{l+m+mf}{1.0}

\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{123}
\PY{n}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}

\PY{n}{x}       \PY{c+c1}{\PYZsh{} prints 123, x in the outer scope is unchanged}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
123
\end{Verbatim}
\end{tcolorbox}
        
    However, if a variable is a mutable object (such as a \texttt{list} or a
\texttt{dict}), the function can use its own copy of the reference to
that object to modify the object even in the outer scope:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} uses reference x to modify list object outside of func()}
    \PY{n}{x}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}

\PY{n}{lst} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
\PY{n}{func}\PY{p}{(}\PY{n}{lst}\PY{p}{)}
\PY{n}{lst}     \PY{c+c1}{\PYZsh{} prints [1,2,3,4]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[1, 2, 3, 4]
\end{Verbatim}
\end{tcolorbox}
        
    Nevertheless, even for mutable objects the rule from above applies: when
a new value is \emph{assigned} to a named argument, that name then
references a different object, leaving the original object unmodified:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} this does not modify object in outer scope,}
    \PY{c+c1}{\PYZsh{} x now references a new (local) object.}
    \PY{n}{x} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}

\PY{n}{lst} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
\PY{c+c1}{\PYZsh{} pass list, which is mutable and can thus be changed in func()}
\PY{n}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}

\PY{n}{lst}     \PY{c+c1}{\PYZsh{} prints [1,2,3]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[1, 2, 3]
\end{Verbatim}
\end{tcolorbox}
        
    For immutable objects such as tuples, the reference passed to the
function of course cannot be used to modify the object inside the
function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n}{x}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{modified in func}\PY{l+s+s1}{\PYZsq{}}
    
\PY{n}{items} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}          \PY{c+c1}{\PYZsh{} create tuple of integers}
\PY{n}{func}\PY{p}{(}\PY{n}{items}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-red}{TypeError}\textcolor{ansi-red}{:} 'tuple' object does not support item assignment

    \end{Verbatim}

    Passing in a mutable collection such as a list, however, works as
expected:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{items} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}

\PY{n}{func}\PY{p}{(}\PY{n}{items}\PY{p}{)}

\PY{n}{items}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
['modified in func', 2, 3]
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{methods}{%
\subsubsection{Methods}\label{methods}}

Methods are simply functions that perform an action on a particular
object which they are bound to. We will not write methods in this course
ourselves (they are part of what's called object-oriented programming),
but we frequently use them when we invoke actions on objects such as
lists:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{27}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Create a list}
\PY{n}{lst} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}

\PY{c+c1}{\PYZsh{} append() is a method of the list class and can be invoked}
\PY{c+c1}{\PYZsh{} on list objects.}
\PY{n}{lst}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}
\PY{n}{lst}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{27}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[1, 2, 3, 4]
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{functions-as-objects}{%
\subsubsection{Functions as objects}\label{functions-as-objects}}

Functions are objects in their own right, which means that you can
perform various operations with them:

\begin{itemize}
\tightlist
\item
  Assign a function to a variable.
\item
  Store functions in collections.
\item
  Pass function as an argument to other functions.
\end{itemize}

\vspace{1em}\emph{Examples:}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{28}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func1}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func1 called with argument }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{func2}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func2 called with argument }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}


\PY{c+c1}{\PYZsh{} List of functions}
\PY{n}{funcs} \PY{o}{=} \PY{p}{[}\PY{n}{func1}\PY{p}{,} \PY{n}{func2}\PY{p}{]}

\PY{c+c1}{\PYZsh{} Assign functions to variable f}
\PY{k}{for} \PY{n}{f} \PY{o+ow}{in} \PY{n}{funcs}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} call function referenced by f}
    \PY{n}{f}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{foo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func1 called with argument foo
func2 called with argument foo
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Pass one function as argument to another function}
\PY{n}{func1}\PY{p}{(}\PY{n}{func2}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func1 called with argument <function func2 at 0x7fb6d94f6b00>
    \end{Verbatim}

    \hypertarget{lambda-expressions}{%
\subsubsection{lambda expressions}\label{lambda-expressions}}

You can think of lambda expressions as light-weight functions. The
syntax is

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lambda}\NormalTok{ x: }\OperatorTok{\textless{}}\NormalTok{do something }\ControlFlowTok{with}\NormalTok{ x}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

The return value of a lambda expression is whatever its body evaluates
to. There is no need (or possibility) to explicitly add a
\texttt{return} statement.

One big difference to regular functions is that lambda expressions are
\emph{expressions}, not statements.

\begin{itemize}
\tightlist
\item
  At this point we gain little from a technical discussion on
  \emph{statements} vs \emph{expressions}. Loosely speaking, statements
  are one level above expressions in the Python syntax hierarchy, and
  the language puts restrictions on where statements can appear.
  Function definitions, \texttt{for} and \texttt{while} loops, and
  \texttt{if/elif/else} blocks are statements, among others.
\item
  Conversely, \emph{expressions} are more flexible and can appear
  basically anywhere. They usually evaluate to some object that can be
  assigned, passed to a function, \etc, whereas statements usually
  can't.
\end{itemize}

The take-away is that we can fiddle in lambda expressions almost
anywhere, even as arguments in function calls!

For example, we might have a function that applies some algebraic
operation to its arguments, and the operation can be flexibly defined by
the caller.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{n}{items}\PY{p}{,} \PY{n}{operation}\PY{o}{=}\PY{k}{lambda} \PY{n}{z}\PY{p}{:} \PY{n}{z} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} default operation: increment value by 1}
    \PY{n}{result} \PY{o}{=} \PY{p}{[}\PY{n}{operation}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{items}\PY{p}{]}
    \PY{k}{return} \PY{n}{result}

\PY{n}{numbers} \PY{o}{=} \PY{p}{[}\PY{l+m+mf}{1.0}\PY{p}{,} \PY{l+m+mf}{2.0}\PY{p}{,} \PY{l+m+mf}{3.0}\PY{p}{]}
\PY{c+c1}{\PYZsh{} call with default operation}
\PY{n}{func}\PY{p}{(}\PY{n}{numbers}\PY{p}{)}               \PY{c+c1}{\PYZsh{} prints [2.0, 3.0, 4.0]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[2.0, 3.0, 4.0]
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} We can also use lambda expressions to specify}
\PY{c+c1}{\PYZsh{} an alternative operation directly in the call!}

\PY{n}{func}\PY{p}{(}\PY{n}{numbers}\PY{p}{,} \PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{2.0}\PY{p}{)}     \PY{c+c1}{\PYZsh{} prints [1.0, 4.0, 9.0]}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[1.0, 4.0, 9.0]
\end{Verbatim}
\end{tcolorbox}
        
    While we could have defined the operation using a ``regular'' function
statement, this is shorter.


\hypertarget{modules-and-packages}{%
\subsection{Modules and packages}\label{modules-and-packages}}

\hypertarget{modules}{%
\subsubsection{Modules}\label{modules}}

Modules allow us to further encapsulate code that implements some
particular functionality.

\begin{itemize}
\tightlist
\item
  Each Python file (with the extension \texttt{.py}) automatically
  corresponds to a module of the same name.
\item
  Objects defined within such a module are by default not visible
  outside of the module, thus helping to avoid naming conflicts.
\end{itemize}

To actually demonstrate the usage of modules, we need to use files
outside of this notebook. To this end, there is an additional Python
file in the current directory:

\begin{verbatim}
lectures/
    unit03_mod.py
\end{verbatim}

The module \texttt{unit03\_mod.py} contains the following definitions:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Contents of unit03\_mod.py}

\CommentTok{\# global variable in this module}
\NormalTok{var }\OperatorTok{=} \StringTok{\textquotesingle{}Variable defined in unit03\_mod\textquotesingle{}}

\CommentTok{\# global function in this module}
\KeywordTok{def}\NormalTok{ func():}
    \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}func in module unit03\_mod called\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    \textbf{Module search path}

Before getting into the details, we first need to verify that we can
import the module \texttt{unit03\_mod} using the \texttt{import}
statement:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{unit03\PYZus{}mod}
\end{Verbatim}
\end{tcolorbox}

    Depending on where exactly you are running this code, the above import
statement might fail with a \texttt{ModuleNotFoundError} (if no error
was raised you can skip the rest of this section). This happens whenever
the directory in which the module resides is not in the \emph{module
search path} used by Python.

To fix this, check the module search path as follows:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{33}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{sys}
\PY{n}{sys}\PY{o}{.}\PY{n}{path}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{33}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
['/home/richard/repos/teaching/python-intro-PGR/lectures',
 '/home/richard/.conda/envs/python-intro-PGR/lib/python310.zip',
 '/home/richard/.conda/envs/python-intro-PGR/lib/python3.10',
 '/home/richard/.conda/envs/python-intro-PGR/lib/python3.10/lib-dynload',
 '',
 '/home/richard/.local/lib/python3.10/site-packages',
 '/home/richard/.conda/envs/python-intro-PGR/lib/python3.10/site-packages',
 '/home/richard/.conda/envs/python-intro-PGR/lib/python3.10/site-
packages/PyQt5\_sip-12.11.0-py3.10-linux-x86\_64.egg']
\end{Verbatim}
\end{tcolorbox}
        
    If the \texttt{lectures/} directory is not included in this list, you
can add it manually. For example, this notebook is executed in the git
repository's root directory, you need to exectute

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{34}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{sys}
\PY{c+c1}{\PYZsh{} add lectures/ directory using a relative path}
\PY{n}{sys}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{./lectures/}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}        
\end{Verbatim}
\end{tcolorbox}

    \textbf{Note}: Loading custom modules that reside in the GitHub
repository currently does \emph{not} work if you opened this notebook in
Google Colab.

    \textbf{Importing symbols}

We now want to use \texttt{func} and \texttt{var} in our notebook.
However, by default these symbols are not visible and first need to be
imported. We can do this in several ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We can import the module and use fully qualified names to reference
  objects from \texttt{unit03\_mod}.
\item
  We can select which names from \texttt{unit03\_mod} should be directly
  accessible.
\end{enumerate}

The first variant looks like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{35}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{unit03\PYZus{}mod}

\PY{c+c1}{\PYZsh{} Access variable defined in unit03\PYZus{}mod}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{unit03\PYZus{}mod}\PY{o}{.}\PY{n}{var}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Call function defined in unit03\PYZus{}mod}
\PY{n}{unit03\PYZus{}mod}\PY{o}{.}\PY{n}{func}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Variable defined in unit03\_mod
func in module unit03\_mod called
    \end{Verbatim}

    If a symbol from \texttt{unit03\_mod} is used frequently, we might want
to make it accessible without the \texttt{unit03\_mod} prefix. This is
the second variant:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{unit03\PYZus{}mod} \PY{k+kn}{import} \PY{n}{var}\PY{p}{,} \PY{n}{func}

\PY{c+c1}{\PYZsh{} Access variable defined in unit03\PYZus{}mod}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{var}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Call function defined in unit03\PYZus{}mod}
\PY{n}{func}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Variable defined in unit03\_mod
func in module unit03\_mod called
    \end{Verbatim}

    What if our notebook itself defines a function \texttt{func()} which
would overwrite the reference to the one imported from
\texttt{unit03\_mod}, as in the following example?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{37}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{unit03\PYZus{}mod} \PY{k+kn}{import} \PY{n}{func}

\PY{c+c1}{\PYZsh{} Calls func() defined in unit03\PYZus{}mod}
\PY{n}{func}\PY{p}{(}\PY{p}{)}         

\PY{c+c1}{\PYZsh{} overwrites definition from unit03\PYZus{}mod with local version}
\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func in notebook called}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Calls func() defined in notebook}
\PY{n}{func}\PY{p}{(}\PY{p}{)}          
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func in module unit03\_mod called
func in notebook called
    \end{Verbatim}

    In such a scenario, we can assign aliases to imported symbols using
\texttt{as}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{38}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{unit03\PYZus{}mod} \PY{k+kn}{import} \PY{n}{func} \PY{k}{as} \PY{n}{imported\PYZus{}func}     \PY{c+c1}{\PYZsh{} The function formerly known}
                                                 \PY{c+c1}{\PYZsh{} as func is now imported\PYZus{}func}

\PY{k}{def} \PY{n+nf}{func}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{func in notebook called}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} call our own func}
\PY{n}{func}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} call func from module unit03\PYZus{}mod}
\PY{n}{imported\PYZus{}func}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func in notebook called
func in module unit03\_mod called
    \end{Verbatim}

    We can even alias the module name itself, as we frequently do with
widely used modules such as \texttt{numpy}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{39}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{unit03\PYZus{}mod} \PY{k}{as} \PY{n+nn}{u3m}

\PY{n}{u3m}\PY{o}{.}\PY{n}{func}\PY{p}{(}\PY{p}{)}    \PY{c+c1}{\PYZsh{} call function from module unit03\PYZus{}mod}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
func in module unit03\_mod called
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{40}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} universal convention to import numpy like this}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{packages}{%
\subsubsection{Packages}\label{packages}}

Packages are roughly speaking collections of modules and a little magic
on top. We will not be creating packages, but we have already been using
them: basically everything besides the built-in functions is defined in
some package. For example, the NumPy library is a collection of
packages.


\hypertarget{optional-exercises}{%
\subsection{Optional exercises}\label{optional-exercises}}

    \hypertarget{exercise-1-sign-function}{%
\subsubsection{Exercise 1: Sign
function}\label{exercise-1-sign-function}}

Implement a function \texttt{sign} which returns the following values:
\[
sign(x) = 
\begin{cases}
-1 & \text{if } x < 0 \\
\phantom{-} 0 & \text{if } x = 0 \\
\phantom{-} 1 & \text{if } x > 0
\end{cases}
\] Test your function on a negative, zero and positive argument.

    \hypertarget{exercise-2-sum-of-arbitrary-number-of-elements}{%
\subsubsection{Exercise 2: Sum of arbitrary number of
elements}\label{exercise-2-sum-of-arbitrary-number-of-elements}}

Create a function called \texttt{my\_sum} which accepts an arbitrary
number of arguments (possibly zero) and returns their sum. Assume that
all arguments are numeric.

Test your function with the following arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_sum(}\FloatTok{10.0}\NormalTok{)    }\CommentTok{\# one argument}
\NormalTok{my\_sum(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)   }\CommentTok{\# multiple arguments}
\NormalTok{my\_sum()        }\CommentTok{\# no arguments}
\end{Highlighting}
\end{Shaded}

Make sure that in the last case your function returns zero, which is the
sum over an empty set.

    \hypertarget{exercise-3-fibonacci-sequence}{%
\subsubsection{Exercise 3: Fibonacci
sequence}\label{exercise-3-fibonacci-sequence}}

A classical introductory exercise to programming is to write a function
that returns the first \(n\) terms of the Fibonacci sequence. The
\(i\)-th element of this sequence is the integer \(x_i\) defined as \[
x_i = 
\begin{cases} 0 & \text{if } i = 0   \\
    1  & \text{if } i = 1\\
    x_{i-1} + x_{i-2} & \text{else}
\end{cases}
\]

Write a function \texttt{fibonacci(i)},

\begin{verbatim}
def fibonacci(i):
    ...
\end{verbatim}

which returns the \(i\)-th item in the sequence using recursion. A
recursive function is a function that calls itself to perform (part of)
its task, \ie you should compute \(x_i\) like this:

\begin{verbatim}
xi = fibonacci(i-1) + fibonacci(i-2)
\end{verbatim}

Use this function to compute the first 10 elements of this sequence with
a list comprehension.

    \hypertarget{exercise-4-factorials}{%
\subsubsection{Exercise 4: Factorials}\label{exercise-4-factorials}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement a function that computes the factorial of a non-negative
  integer \(n\) defined as \(n! = \prod_{i=1}^n i\). Keep in mind that
  this definition implies that \(0! = 1\). Use the list comprehension
  syntax to create a tuple that contains the factorials for the integers
  \(n=1,\dots,10\).

  \emph{Hint:} The factorial can be written as a recurrence relation
  \(n! = n \cdot (n-1)!\), which you can use to implement the recursive
  function.
\item
  Provide an alternative implementation that does not rely on recursion,
  but instead uses NumPy's \texttt{prod()} function to compute the
  product of a sequence of numbers. Again, create a \texttt{tuple} that
  contains the factorials for the integers \(n=1,\dots,10\) using a list
  comprehension.

  \emph{Hint 1:} To compute the product of the integers
  \(i,i+1,\dots,j\), you can use \texttt{np.prod(range(i,j+1))}.

  \emph{Hint 2:} The product of an empty set is 1, which is what
  \texttt{np.prod()} returns.
\end{enumerate}

    \hypertarget{exercise-5-bisection-root-finding-algorithm-advanced}{%
\subsubsection{Exercise 5: Bisection root-finding algorithm
(advanced)}\label{exercise-5-bisection-root-finding-algorithm-advanced}}

We revisit the binary search algorithm from unit 2, this time applied to
finding the root of a continuous function. This is called the
\href{https://en.wikipedia.org/wiki/Bisection_method}{bisection method}.

Implement a function \texttt{bisection(f,\ a,\ b,\ tol,\ xtol)} which
finds the root of the function \(f(x)\), \ie the value \(x_0\) where
\(f(x_0) = 0\), on the interval \([a,b]\). Assume that \(a<b\) and that
the function values \(f(a)\) and \(f(b)\) have opposite signs.

Test your implementation using the function \(f(x) = x^2 - 4\) on the
interval \([-3,0]\), which has a (unique) root at \(x_0 = -2\).

\emph{Hint:} The bisection algorithm proceeds as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define tolerance levels \(\epsilon > 0\) and \(\epsilon_x > 0\). The
  algorithm completes successfully whenever we have either
  \(|f(x_0)| < \epsilon\) or \(|b-a|<\epsilon_x\).
\item
  Main loop of the algorithm:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Compute the midpoint \(x_m = (a+b)/2\)
  \item
    Compute function value \(f_m = f(x_m)\)
  \item
    If either \(|f_m| < \epsilon\) or \(|b-a|< \epsilon_x\), accept
    \(x_m\) as the solution and exit.
  \item
    Otherwise, update either \(a\) or \(b\):

    \begin{enumerate}
    \def\labelenumiii{\arabic{enumiii}.}
    \item
      If \(sign(f(b)) = sign(f_m)\), set \(b = x_m\)

      \emph{Hint:} One way to check whether two non-zero values have the
      same sign is to check if \(f(b) \cdot f_m > 0\).
    \item
      Otherwise, \(a = x_m\)
    \end{enumerate}
  \item
    Proceed to next iteration of main loop.
  \end{enumerate}
\end{enumerate}

    \hypertarget{exercise-6-root-finding-with-scipy}{%
\subsubsection{Exercise 6: Root-finding with
SciPy}\label{exercise-6-root-finding-with-scipy}}

In the previous exercise, you were asked to implement your own
root-finder based on the bisection algorithm. This will rarely be
necessary in real applications since libraries such as SciPy implement
ready-to-use root-finding algorithms in the
\href{https://docs.scipy.org/doc/scipy/reference/optimize.html}{\texttt{scipy.optimize}}
package for you. In this exercise, we explore how to use these routines.

Assume we have a function of a single scalar variable, \(f(x)\),

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ fcn(x):}
    \CommentTok{\# Compute function value fx = f(x)}
    \ControlFlowTok{return}\NormalTok{ fx}
\end{Highlighting}
\end{Shaded}

which has a root on the interval \([a, b]\). We can use SciPy's
implementation of the bisection algorithm
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html\#scipy.optimize.bisect}{\texttt{bisect()}}
as follows:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ scipy.optimize }\ImportTok{import}\NormalTok{ bisect}

\NormalTok{root }\OperatorTok{=}\NormalTok{ bisect(fcn, a, b)}
\end{Highlighting}
\end{Shaded}

Define a Python function \(f(x) = x^2 - 4\) and use SciPy's
\texttt{bisect()} to locate the root on the interval \([-3, 0]\). Print
the root of \(f(x)\).

    \hypertarget{exercise-7-minimisation-with-scipy}{%
\subsubsection{Exercise 7: Minimisation with
SciPy}\label{exercise-7-minimisation-with-scipy}}

In addition to the root-finding routines discussed in the previous
exercise, the
\href{https://docs.scipy.org/doc/scipy/reference/optimize.html}{\texttt{scipy.optimize}}
package also includes numerous functions to perform minimisation. We
demonstrate one such application here.

For a function \(f(x)\) of a scalar variable \(x\), we can use the
function
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html}{\texttt{minimize\_scalar()}}
to perform the minimization as follows:

    \begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ scipy.optimize }\ImportTok{import}\NormalTok{ minimize\_scalar}

\CommentTok{\# Call minimizer with custom function fcn}
\NormalTok{result }\OperatorTok{=}\NormalTok{ minimize\_scalar(fcn)}

\CommentTok{\# Print minimisation result}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f\textquotesingle{}Minimum found at }\SpecialCharTok{\{}\NormalTok{result}\SpecialCharTok{.x\}}\SpecialStringTok{\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

    For this to work, we first need to define the objective function
\texttt{fcn} or pass a lambda expression. Importantly,
\texttt{minimize\_scalar()} returns an object of type
\href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html}{\texttt{OptimizeResult}}
which contains information about the minimisation process. For our
purposes, the most relevant attribute is \texttt{x} which can be used to
recover the minimum, as illustrated above. The function value at the
minimum is stored in the attribute \texttt{fun}.

    Consider the function \(f(x) = (x - 2)^2 + 1\). Use SciPy's
\texttt{minimize\_scalar()} to find the (unique) global minimum of this
function numerically and print the minimum (the minimum is located at
\(x=2\) and can easily be found analytically in this case).

    \hypertarget{exercise-8-maximisation-of-multivariate-functions-with-scipy}{%
\subsubsection{Exercise 8: Maximisation of multivariate functions with
SciPy}\label{exercise-8-maximisation-of-multivariate-functions-with-scipy}}

Frequently, we want to maximize a multivariate function that depends on
more than one scalar argument. To fix ideas, assume that we have an
objective function given by \(f(x_1, x_2; a, b)\) where \(x_1\) and
\(x_2\) are the arguments while \(a\) and \(b\) are additional
parameters that are assumed constant. To find the maximum of such a
function, we proceed as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We use SciPy's
  \href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html}{\texttt{minimize()}}
  which can handle functions with multiple arguments. These arguments
  have to be passed in as a vector, \ie the objective has the form
  \(f(\mathbf{x})\) with \(\mathbf{x} \in \mathbb{R}^n\).
\item
  Because SciPy routines all perform minimisation whereas we are
  interested in maximising the function \(f(\mathbf{x})\), we need to
  return the \emph{negative} value of our objective function.
\item
  If \(f(\bullet)\) requires additional parameters, \eg
  \(f(\mathbf{x}; a, b)\), we can pass these additional arguments as
  \texttt{args=(a,b)} to \texttt{minimize()}.
\item
  Lastly, \texttt{minimize()} requires an initial guess \(\mathbf{x}_0\)
  which can be passed as \texttt{x0=...}.
\end{enumerate}

The code fragment below illustrates all of these points.

    \begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ scipy.optimize }\ImportTok{import}\NormalTok{ minimize}

\KeywordTok{def}\NormalTok{ fcn(x, a, b):}
    \CommentTok{\# Compute function value f(x, a, b)}
    \CommentTok{\# Return NEGATIVE function value for minimiser}
    \ControlFlowTok{return} \OperatorTok{{-}}\NormalTok{ fx}

\NormalTok{result }\OperatorTok{=}\NormalTok{ minimize(fcn, x0}\OperatorTok{=}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{), args}\OperatorTok{=}\NormalTok{(a, b))}
\end{Highlighting}
\end{Shaded}

    Now consider the function
\(f(x_1, x_2; a,b) = - \Bigl[(x_1 - a)^2 + (x_2 - b)^2 \Bigr]\) where
\(\mathbf{x} = (x_1, x_2)\) is the two-dimensional argument and \(a\)
and \(b\) are additional parameters. Find the maximum of this function
for \(a=1\) and \(b=-2\) and print both the maximiser \(\mathbf{x}\) and
the function value at the maximum. Define the function \(f(\bullet)\) as
shown in the above code fragment, \ie \(a\) and \(b\) should be passed
as additional arguments.


\hypertarget{solutions}{%
\subsection{Solutions}\label{solutions}}

\hypertarget{solution-for-exercise-1}{%
\subsubsection{Solution for exercise 1}\label{solution-for-exercise-1}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{41}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{k}{def} \PY{n+nf}{sign}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{x} \PY{o}{\PYZlt{}} \PY{l+m+mf}{0.0}\PY{p}{:}
        \PY{k}{return} \PY{o}{\PYZhy{}}\PY{l+m+mf}{1.0}
    \PY{k}{elif} \PY{n}{x} \PY{o}{==} \PY{l+m+mf}{0.0}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mf}{0.0}
    \PY{k}{elif} \PY{n}{x} \PY{o}{\PYZgt{}} \PY{l+m+mf}{0.0}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mf}{1.0}
    \PY{k}{else}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Argument is not a proper numerical value, return NaN}
        \PY{c+c1}{\PYZsh{} (NaN = Not a Number)}
        \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{nan}

\PY{c+c1}{\PYZsh{} Test on a few values}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{sign}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{123}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{sign}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{sign}\PY{p}{(}\PY{l+m+mi}{12345}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
-1.0
0.0
1.0
    \end{Verbatim}

    Note that NumPy has a ``proper'' sign function, \texttt{np.sign()},
which implements the same logic but is more robust, accepts array
arguments, \etc

    \hypertarget{solution-for-exercise-2}{%
\subsubsection{Solution for exercise 2}\label{solution-for-exercise-2}}

For a function to accept an arbitrary number of elements, we need to
declare an \texttt{*args} argument.

One possible implementation of \texttt{my\_sum()} looks as follows:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{42}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{my\PYZus{}sum}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Initialise sum to 0}
    \PY{n}{s} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n}{args}\PY{p}{:}
        \PY{n}{s} \PY{o}{+}\PY{o}{=} \PY{n}{x}
    \PY{k}{return} \PY{n}{s}


\PY{c+c1}{\PYZsh{} Test with built\PYZhy{}in range() object}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}sum}\PY{p}{(}\PY{l+m+mf}{10.0}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}sum}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}sum}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
10.0
6
0
    \end{Verbatim}

    Of course in real code we would use the built-in function
\texttt{sum()}, or preferably the NumPy variant \texttt{np.sum()}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{43}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{l+m+mf}{10.0}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Need to pass argument as collection}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} np.sum() cannot be invoked without arguments, but we can}
\PY{c+c1}{\PYZsh{} call it with an empty tuple ()}
\PY{n}{np}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
10.0
6
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{43}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0.0
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{solution-for-exercise-3}{%
\subsubsection{Solution for exercise 3}\label{solution-for-exercise-3}}

The recursive definition of \texttt{fibonacci(i)} could look like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{44}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{fibonacci}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{i} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} No recursion needed}
        \PY{n}{xi} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{k}{elif} \PY{n}{i} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} No recursion needed}
        \PY{n}{xi} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{k}{else}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Assume that i \PYZgt{} 1. We will learn later how to}
        \PY{c+c1}{\PYZsh{} return an error if this is not the case.}
        \PY{c+c1}{\PYZsh{} Use recursion to compute the two preceding values}
        \PY{c+c1}{\PYZsh{} of the sequence.}
        \PY{n}{xi} \PY{o}{=} \PY{n}{fibonacci}\PY{p}{(}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{+} \PY{n}{fibonacci}\PY{p}{(}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{)}
    \PY{k}{return} \PY{n}{xi}

\PY{c+c1}{\PYZsh{} Compute the first 10 elements of the sequence using a list comprehension}
\PY{n}{first10} \PY{o}{=} \PY{p}{[}\PY{n}{fibonacci}\PY{p}{(}\PY{n}{i}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}
\PY{n}{first10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{44}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
\end{Verbatim}
\end{tcolorbox}
        
    Note that this is a terribly inefficient way to compute things, as the
same elements of the sequence will needlessly be calculated over and
over again.

Also, Python has a built-in recursion limit, so you cannot call a
function recursively arbitrarily many times. You can find out what this
limit is as follows:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{45}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{sys}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{getrecursionlimit}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
3000
    \end{Verbatim}

    \hypertarget{solution-for-exercise-4}{%
\subsubsection{Solution for exercise 4}\label{solution-for-exercise-4}}

The following code shows a function computing the factorial \(n!\) using
recursion:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{46}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{factorial}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{n} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mi}{1}
    \PY{k}{else}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Use recursion to compute factorial}
        \PY{k}{return} \PY{n}{n} \PY{o}{*} \PY{n}{factorial}\PY{p}{(}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}

\PY{n}{fact10} \PY{o}{=} \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{factorial}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
\PY{n}{fact10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{46}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880)
\end{Verbatim}
\end{tcolorbox}
        
    An implementation without recursion can be created using NumPy's
\texttt{prod()} function which computes the product of a sequence of
numbers:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{47}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{n}{fact10} \PY{o}{=}  \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{prod}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)} \PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
\PY{n}{fact10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{47}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1.0, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880)
\end{Verbatim}
\end{tcolorbox}
        
    Notice that the first element of this sequence is a floating-point value
1.0, while the remaining elements are integers. Why is that? Examine the
argument passed to \texttt{np.prod()} for \texttt{n=0}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{48}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{n} \PY{o}{=} \PY{l+m+mi}{0}
\PY{c+c1}{\PYZsh{} We have to embed range() in an expression that forces the Python}
\PY{c+c1}{\PYZsh{} interpreter to actually expand the range object, such as a tuple().}
\PY{n+nb}{tuple}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{48}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
()
\end{Verbatim}
\end{tcolorbox}
        
    As you see, for \texttt{n=0} this is an empty container without
elements. The mathematical convention is that the product over an empty
set is \(\prod_{i \in \emptyset} = 1\), and this is exactly what
\texttt{np.prod()} returns. However, by default NumPy creates
floating-point values, and so the return value is 1.0, not 1.

You can get around this by explicitly specifying the data type using the
\texttt{dtype} argument, which is accepted by many NumPy functions.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{49}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{c+c1}{\PYZsh{} Force result to be of integer type}
\PY{n}{fact10} \PY{o}{=}  \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{prod}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{n+nb}{int}\PY{p}{)} \PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
\PY{n}{fact10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{49}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880)
\end{Verbatim}
\end{tcolorbox}
        
    Alternatively, we can use \texttt{np.arange()} instead of
\texttt{range()} as the former by default returns integer arrays, even
if they are empty:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{50}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{c+c1}{\PYZsh{} Force result to be of integer type}
\PY{n}{fact10} \PY{o}{=}  \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{prod}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)} \PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
\PY{n}{fact10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{50}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880)
\end{Verbatim}
\end{tcolorbox}
        
    Finally, you of course would not need to implement the factorial
function yourself, as there is one in the \texttt{math} module shipped
with Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{51}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{math}
\PY{n}{fact10} \PY{o}{=} \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{math}\PY{o}{.}\PY{n}{factorial}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
\PY{n}{fact10}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{51}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
(1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880)
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{solution-for-exercise-5}{%
\subsubsection{Solution for exercise 5}\label{solution-for-exercise-5}}

    Below you find a simple implementation of a bisection algorithm. This
function does not perform any error checking and assumes that the
initial bracket \([a,b]\) actually contains a root, and that the values
\(f(a)\) and \(f(b)\) have opposite signs.

Note that we impose two termination criteria, and the algorithm will end
successfully whenever one of them is satisfied:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The function value is sufficiently close to zero,
  \ie \(|f(x_0)| < \epsilon\) for some small \(\epsilon > 0\).
\item
  The bracket is sufficiently small, \ie \(|b-a| < \epsilon_x\), again
  for some small \(\epsilon_x > 0\)
\end{enumerate}

This is standard practice in numerical optimisation since we don't want
the algorithm to continue unnecessarily if the desired degree of
precision was achieved.

We specify the termination tolerance as optional arguments \texttt{tol}
and \texttt{xtol} with sensible defaults. We also add the maximum
permissible number of iterations as an optional argument
\texttt{maxiter}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{52}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{bisect}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{tol}\PY{o}{=}\PY{l+m+mf}{1.0e\PYZhy{}6}\PY{p}{,} \PY{n}{xtol}\PY{o}{=}\PY{l+m+mf}{1.0e\PYZhy{}6}\PY{p}{,} \PY{n}{maxiter}\PY{o}{=}\PY{l+m+mi}{100}\PY{p}{)}\PY{p}{:}

    \PY{k}{for} \PY{n}{iteration} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{maxiter}\PY{p}{)}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Compute candidate value as midpoint between a and b}
        \PY{n}{mid} \PY{o}{=} \PY{p}{(}\PY{n}{a} \PY{o}{+} \PY{n}{b}\PY{p}{)} \PY{o}{/} \PY{l+m+mf}{2.0}
        \PY{k}{if} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)} \PY{o}{\PYZlt{}} \PY{n}{xtol}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Remaining interval is too small}
            \PY{k}{break}

        \PY{n}{fmid} \PY{o}{=} \PY{n}{f}\PY{p}{(}\PY{n}{mid}\PY{p}{)}

        \PY{k}{if} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{fmid}\PY{p}{)} \PY{o}{\PYZlt{}} \PY{n}{tol}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} function value is close enough to zero}
            \PY{k}{break}

        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Iteration }\PY{l+s+si}{\PYZob{}}\PY{n}{iteration}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{: f(mid) = }\PY{l+s+si}{\PYZob{}}\PY{n}{fmid}\PY{l+s+si}{:}\PY{l+s+s1}{.4e}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{if} \PY{n}{fmid}\PY{o}{*}\PY{n}{f}\PY{p}{(}\PY{n}{b}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mf}{0.0}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} f(mid) and f(b) have the same sign, update upper bound b}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{  Updating upper bound to }\PY{l+s+si}{\PYZob{}}\PY{n}{mid}\PY{l+s+si}{:}\PY{l+s+s1}{.8f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
            \PY{n}{b} \PY{o}{=} \PY{n}{mid}
        \PY{k}{else}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} f(mid) and f(a) have the same sign, or at least one of}
            \PY{c+c1}{\PYZsh{} them is zero.}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{  Updating lower bound to }\PY{l+s+si}{\PYZob{}}\PY{n}{mid}\PY{l+s+si}{:}\PY{l+s+s1}{.8f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
            \PY{n}{a} \PY{o}{=} \PY{n}{mid}

    \PY{k}{return} \PY{n}{mid}

\PY{c+c1}{\PYZsh{} Compute root of f(x) = x\PYZca{}2 \PYZhy{} 4 on the interval [\PYZhy{}3, 0]}
\PY{c+c1}{\PYZsh{} We pass the function f as the first argument, and use a lambda expression}
\PY{c+c1}{\PYZsh{} to define the function directly in the call.}
\PY{n}{x0} \PY{o}{=} \PY{n}{bisect}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{2.0} \PY{o}{\PYZhy{}} \PY{l+m+mf}{4.0}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mf}{3.0}\PY{p}{,} \PY{l+m+mf}{0.0}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print root. The true value is \PYZhy{}2.0}
\PY{n}{x0}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Iteration 0: f(mid) = -1.7500e+00
  Updating upper bound to -1.50000000
Iteration 1: f(mid) = 1.0625e+00
  Updating lower bound to -2.25000000
Iteration 2: f(mid) = -4.8438e-01
  Updating upper bound to -1.87500000
Iteration 3: f(mid) = 2.5391e-01
  Updating lower bound to -2.06250000
Iteration 4: f(mid) = -1.2402e-01
  Updating upper bound to -1.96875000
Iteration 5: f(mid) = 6.2744e-02
  Updating lower bound to -2.01562500
Iteration 6: f(mid) = -3.1189e-02
  Updating upper bound to -1.99218750
Iteration 7: f(mid) = 1.5640e-02
  Updating lower bound to -2.00390625
Iteration 8: f(mid) = -7.8087e-03
  Updating upper bound to -1.99804688
Iteration 9: f(mid) = 3.9072e-03
  Updating lower bound to -2.00097656
Iteration 10: f(mid) = -1.9529e-03
  Updating upper bound to -1.99951172
Iteration 11: f(mid) = 9.7662e-04
  Updating lower bound to -2.00024414
Iteration 12: f(mid) = -4.8827e-04
  Updating upper bound to -1.99987793
Iteration 13: f(mid) = 2.4414e-04
  Updating lower bound to -2.00006104
Iteration 14: f(mid) = -1.2207e-04
  Updating upper bound to -1.99996948
Iteration 15: f(mid) = 6.1035e-05
  Updating lower bound to -2.00001526
Iteration 16: f(mid) = -3.0518e-05
  Updating upper bound to -1.99999237
Iteration 17: f(mid) = 1.5259e-05
  Updating lower bound to -2.00000381
Iteration 18: f(mid) = -7.6294e-06
  Updating upper bound to -1.99999809
Iteration 19: f(mid) = 3.8147e-06
  Updating lower bound to -2.00000095
Iteration 20: f(mid) = -1.9073e-06
  Updating upper bound to -1.99999952
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{52}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
-2.000000238418579
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{solution-for-exercise-6}{%
\subsubsection{Solution for exercise 6}\label{solution-for-exercise-6}}

    All we need to do is to define the function \texttt{fcn} and the
interval boundaries \texttt{a} and \texttt{b} which we then pass to
SciPy's \texttt{bisect()}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{53}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{bisect}

\PY{c+c1}{\PYZsh{} Define function whose root should be located}
\PY{k}{def} \PY{n+nf}{fcn}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n}{fx} \PY{o}{=} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{2.0} \PY{o}{\PYZhy{}} \PY{l+m+mf}{4.0}
    \PY{k}{return} \PY{n}{fx}

\PY{c+c1}{\PYZsh{} Interval for root\PYZhy{}finder}
\PY{n}{a} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{3}
\PY{n}{b} \PY{o}{=} \PY{l+m+mi}{1}

\PY{c+c1}{\PYZsh{} Call Scipy\PYZsq{}s bisect() to do all the work}
\PY{n}{x0} \PY{o}{=} \PY{n}{bisect}\PY{p}{(}\PY{n}{fcn}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print root}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Root is located at }\PY{l+s+si}{\PYZob{}}\PY{n}{x0}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Root is located at -2.0
    \end{Verbatim}

    \hypertarget{solution-for-exercise-7}{%
\subsubsection{Solution for exercise 7}\label{solution-for-exercise-7}}

To find the minimum of the function \(f(x) = (x - 2)^2 + 1\), we can
simply pass a lambda expression to \texttt{minimize\_scalar()} as
follows:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{54}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize\PYZus{}scalar}

\PY{c+c1}{\PYZsh{} Call minimizer with lambda expression}
\PY{n}{result} \PY{o}{=} \PY{n}{minimize\PYZus{}scalar}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{p}{(}\PY{n}{x}\PY{o}{\PYZhy{}}\PY{l+m+mf}{2.0}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{2.0} \PY{o}{+} \PY{l+m+mf}{1.0}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print minimisation result}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Minimum found at }\PY{l+s+si}{\PYZob{}}\PY{n}{result}\PY{o}{.}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Minimum found at 1.9999999999999998
    \end{Verbatim}

    \hypertarget{solution-for-exercise-8}{%
\subsubsection{Solution for exercise 8}\label{solution-for-exercise-8}}

It is straightforward to show that the maximum of this function is
located at \((1, -2)\) which is what \texttt{minimize()} returns:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{55}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{optimize} \PY{k+kn}{import} \PY{n}{minimize}

\PY{k}{def} \PY{n+nf}{fcn}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Unpack vector x into scalars x1 and x2}
    \PY{n}{x1}\PY{p}{,} \PY{n}{x2} \PY{o}{=} \PY{n}{x}
    \PY{c+c1}{\PYZsh{} Evaluate function f(x1, x2)}
    \PY{n}{fx} \PY{o}{=} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{p}{(}\PY{n}{x1} \PY{o}{\PYZhy{}} \PY{n}{a}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{2.0} \PY{o}{+} \PY{p}{(}\PY{n}{x2} \PY{o}{\PYZhy{}} \PY{n}{b}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{2.0}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Return NEGATIVE function value for minimiser}
    \PY{k}{return} \PY{o}{\PYZhy{}} \PY{n}{fx}

\PY{c+c1}{\PYZsh{} Additional arguments passed to objective}
\PY{n}{a} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{b} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{2}
\PY{n}{args} \PY{o}{=} \PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Initial guess}
\PY{n}{x0} \PY{o}{=} \PY{p}{(}\PY{l+m+mf}{0.0}\PY{p}{,} \PY{l+m+mf}{0.0}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Perform maximisation}
\PY{n}{result} \PY{o}{=} \PY{n}{minimize}\PY{p}{(}\PY{n}{fcn}\PY{p}{,} \PY{n}{x0}\PY{p}{,} \PY{n}{args}\PY{o}{=}\PY{n}{args}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Print maximising vector and function at maximum}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Maximum found at }\PY{l+s+si}{\PYZob{}}\PY{n}{result}\PY{o}{.}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{; f(x) = }\PY{l+s+si}{\PYZob{}}\PY{n}{result}\PY{o}{.}\PY{n}{fun}\PY{l+s+si}{:}\PY{l+s+s1}{.3f}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Maximum found at [ 0.99999998 -2.00000003]; f(x) = 0.000
    \end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
